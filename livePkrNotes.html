<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NLH Hand Noter – ultra-compact</title>
<style>
  :root{
    --bg:#0f1320; --panel:#161b2e; --panel-2:#1b2138; --text:#e8ebff; --muted:#9aa3c7;
    --brand:#6ca2ff; --danger:#ff6b6b; --warn:#ffb86b;
    --border:rgba(255,255,255,.08); --shadow:0 8px 24px rgba(0,0,0,.35);
    --radius:18px; --gap:12px; --pad:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font:500 16px/1.4 Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#0d1120,#0b0f1b);color:var(--text)}
  .app{max-width:none;margin:0;padding:0}
  .banner{position:sticky;top:0;z-index:5;width:100%;padding:18px 16px;background:linear-gradient(180deg,#111731,#0f142b);border-bottom:1px solid var(--border)}
  .title{font-weight:800;letter-spacing:.3px;font-size:22px}

  /* Global street tabs (under the big title) */
  .subnav{width:100%;padding:8px 8px;background:linear-gradient(180deg,#111731,#0f142b);border-bottom:1px solid var(--border)}
  .street-tabs{display:flex;gap:8px;flex-wrap:wrap}
  .street-tabs .btn{border-radius:16px;padding:8px 12px}
  .street-tabs .btn.selected{background:var(--brand);color:#0b1030;border-color:transparent}

  .page{padding:0}
  .grid{display:grid;gap:var(--gap)}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:0;padding:8px}
  .panel h3{margin:0 0 8px;font-size:16px;opacity:.9}
  .row{display:flex;gap:var(--gap);align-items:center;flex-wrap:wrap}
  .small{font-size:13px}
  .muted{color:var(--muted)}

  .btn{appearance:none;border:none;border-radius:12px;padding:10px 12px;background:var(--brand);color:#0a1020;font-weight:800;cursor:pointer;box-shadow:var(--shadow)}
  .btn.ghost{background:transparent;color:#fff;border:1px solid var(--border)}
  .btn.small{padding:4px 6px;border-radius:10px;font-size:12.5px;line-height:1.1}

  .iconbtn{appearance:none;border:1px solid var(--border);background:transparent;color:#fff;
           border-radius:12px;padding:8px 10px;line-height:1;cursor:pointer}
  .iconbtn:hover{border-color:rgba(255,255,255,.22)}

  /* Make currency button bigger in Preflop -> General */
  #viewPreflop #btnCurrency { font-size: 15px; padding: 8px 14px; }

  .btn.selected{background:var(--brand);color:#0b1030;border-color:transparent}
  .btn.selected.small{font-weight:800}

  .list{display:flex;flex-direction:column;gap:10px}
  .item{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px 14px;display:flex;justify-content:space-between;align-items:center}
  .item .meta{font-size:13px;color:var(--muted)}
  .inline-edit{cursor:pointer;border-bottom:1px dotted var(--muted)}

  /* Player rows — ultra compact */
  .pos-row{display:grid;grid-template-columns:70px 1fr;gap:2px;align-items:center;padding:1px 2px;border:1px dashed var(--border);border-radius:10px}
  .pos-info{display:flex;flex-direction:column;gap:1px}
  .pos-label{font-weight:800;cursor:pointer;line-height:1.1;user-select:none}
  .pos-label .is-hero{color:var(--brand);opacity:1;font-weight:700}
  .name-tap{font-size:12px;color:var(--muted);cursor:pointer;line-height:1.1}
  .name-tap:hover{color:#fff}
  .actions{display:grid;grid-template-columns:repeat(auto-fit, minmax(66px,1fr));gap:3px;align-items:stretch}
  .actwrap{display:block;min-width:0}
  .actwrap .btn{width:100%;border-radius:9px;font-size:12px;line-height:1.5}
  .btn-note{font-size:10.5px;color:var(--muted);margin-top:1px;text-align:center;min-height:12px}

  .status{font-size:12px;color:var(--muted)}
  .divider{height:1px;background:var(--border);margin:10px 0}

  .board{display:flex;gap:5px;align-items:center;flex-wrap:wrap}
  .card{display:inline-flex;align-items:center;justify-content:center;border:1px solid var(--border);border-radius:20px;padding:2px 4px;min-width:20px;background:var(--panel-2);font-weight:800;cursor:pointer}

  /* showdown */
  .sd-row{display:grid;grid-template-columns:120px 1fr;gap:6px;align-items:center;padding:5px 6px;border:1px dashed var(--border);border-radius:10px}
  .sd-hand{display:flex;gap:6px;align-items:center}
  .sd-meta{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  .panel.has-sticky{padding-bottom:70px}

  .sticky-bottom{position:sticky;bottom:0;left:0;right:0;display:grid;gap:4px;grid-template-columns:repeat(auto-fit,minmax(72px,1fr));margin:0;padding:10px 4px;background:linear-gradient(180deg,#111731,#0f142b);border-top:1px solid var(--border);z-index:4}
  .sticky-bottom .btn{width:100%;padding:10px 8px;border-radius:10px;font-size:13px;line-height:1.1}

  .btnbar{--gap: 8px;--min-btn: 128px;display: grid;gap: var(--gap);grid-template-columns: repeat(auto-fit, minmax(min(var(--min-btn), 100%), 1fr));max-width: calc(3 * var(--min-btn) + 2 * var(--gap));margin: 0 auto;}
  .btnbar .btn{padding: 8px 10px;border-radius: 10px}

  .nav-back::before{content:"◀";margin-right:3px}
  .nav-next::after{content:"▶";margin-left:3px}

  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:8px;border:none solid var(--border);background:transparent ;font-size:13px}
  input[type="text"],input[type="number"],select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0c1222;color:#e8ebff}
  textarea{width:100%;min-height:120px;border-radius:12px;border:1px solid var(--border);background:#0c1222;color:#e8ebff;padding:10px}

  .modal{display:none;align-items:flex-end;justify-content:center;position:fixed;inset:0;background:rgba(4,6,12,.75);z-index:50}
  .modal.open{display:flex}
  .modal .panel{border-radius:20px 20px 0 0;max-width:720px;width:100%;max-height:92vh;height:92vh;overflow:auto}

  /* Card picker: 4 columns */
  #cardGrid{display:grid;grid-template-columns:repeat(4,minmax(40px,1fr));gap:6px}
  #cardGrid .btn{padding:4px 0;border-radius:10px;margin:0;font-size:13px}
  #cardGrid .btn.unavailable{opacity:.35;filter:grayscale(25%);cursor:not-allowed;color:#c3c8df;background:#121830;border-color:rgba(255,255,255,.12)}
  #cardGrid .btn.selected{background:var(--brand);color:#0b1030;border-color:transparent;opacity:1}
</style>
</head>
<body>
<div class="app">
  <div class="banner"><div class="title">NLH Hand Noter</div></div>

  <!-- Global street menu -->
  <div id="streetMenu" class="subnav" style="display:none">
    <div class="street-tabs">
      <button class="btn ghost small" data-go="preflop">Preflop</button>
      <button class="btn ghost small" data-go="flop">Flop</button>
      <button class="btn ghost small" data-go="turn">Turn</button>
      <button class="btn ghost small" data-go="river">River</button>
      <button class="btn ghost small" data-go="show">Show</button>
    </div>
  </div>

  <!-- HOME -->
  <section id="viewList" class="page">
    <!-- Saved hands -->
    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Saved hands</h3>
        <button class="btn" id="btnNewFromListTop">Start a new hand</button>
      </div>
      <div id="handsList" class="list" style="margin-top:8px"></div>
    </div>

    <!-- Player profiles (Home: categories) -->
    <div class="panel" id="panelProfilesHome">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Player profiles</h3>
      </div>
      <div id="categoriesListHome" class="list"></div>
      <div class="divider"></div>
      <div class="row">
        <input id="categoryNameHome" placeholder="New category name" />
        <button class="btn" id="btnAddCategoryHome">Add category</button>
      </div>
    </div>

    <!-- Sessions placeholder -->
    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Sessions</h3>
      </div>
      <div class="item">No sessions yet.</div>
    </div>
  </section>

  <!-- PREFLOP -->
  <section id="viewPreflop" style="display:none" class="page">
    <div class="panel has-sticky">
      <h3>General</h3>
      <div class="grid" style="grid-template-columns:repeat(3,minmax(0,1fr));gap:10px">
        <div>
          <div class="small muted">Blinds</div>
          <div><span id="lblBlinds" class="inline-edit"></span></div>
        </div>
        <div>
          <div class="small muted">Eff. stack (bb)</div>
          <div><span id="lblStackBB" class="inline-edit"></span></div>
        </div>
        <div>
          <div class="small muted">Eff. stack (<span id="curSymbol">€</span>)</div>
          <div><span id="lblStackEUR" class="inline-edit"></span></div>
        </div>
        <div><div class="small muted">Players</div><select id="selPlayers"></select></div>
        <div>
          <div class="small muted">Currency</div>
          <button class="btn ghost small" id="btnCurrency">€</button>
        </div>
        <div>
          <div class="small muted">Hero cards </div>
          <div class="row">
            <button class="btn ghost small" id="btnHeroCards">Set</button>
            <span id="heroCardsDisp"></span>
          </div>
        </div>
      </div>

      <div class="divider"></div>
      <h3>Preflop action</h3>
      <div id="preflopRows" class="grid" style="gap:4px"></div>

      <div class="divider"></div>
      <div id="queueWrap" style="display:none">
        <div class="small muted">Players who still owe action</div>
        <div id="queue" class="grid" style="gap:4px"></div>
        <div class="divider"></div>
      </div>

      <div class="sticky-bottom">
        <button class="btn ghost" id="btnCancelPF">Cancel</button>
        <button class="btn nav-next" id="btnFinishPF">Flop</button>
      </div>
    </div>
  </section>

  <!-- POSTFLOP (Flop/Turn/River) -->
  <section id="viewStreet" style="display:none" class="page">
    <div class="panel">
      <div class="row" style="justify-content:space-between">
        <h3 id="streetTitle">Flop</h3>
        <div class="badge">Pot now: <span id="potDisp">0</span></div>
      </div>
      <div class="board row">
        <div class="small muted">Board</div>
        <div id="boardCards" class="row"></div>
        <button class="btn ghost small" id="btnEditBoard">Edit board</button>
      </div>
    </div>
    <div class="panel has-sticky" style="margin-top:8px">
      <div id="streetRows" class="grid" style="gap:4px"></div>
      <div class="divider"></div>
      <div id="postQueueWrap" style="display:none">
        <div class="small muted">Players who still owe action</div>
        <div id="postQueue" class="grid" style="gap:4px"></div>
        <div class="divider"></div>
      </div>
      <div class="sticky-bottom">
        <button class="btn ghost" id="btnCancelStreet">Cancel</button>
        <button class="btn ghost nav-back" id="btnBackStreet">Preflop</button>
        <button class="btn nav-next" id="btnNextStreet">Turn</button>
      </div>
    </div>
  </section>

  <!-- SHOWDOWN -->
  <section id="viewShowdown" style="display:none" class="page">
    <div class="panel has-sticky">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Showdown</h3>
        <div class="sd-meta">
          <div class="badge">Final pot: <span id="sdPot">€0</span></div>
          <div class="badge">Effective remaining: <span id="sdEff">€0</span></div>
        </div>
      </div>

      <div class="board row" style="margin-top:8px">
        <div class="small muted">Board</div>
        <div id="sdBoardCards" class="row"></div>
        <button class="btn ghost small" id="btnEditBoardSD">Edit board</button>
      </div>

      <div class="divider"></div>
      <div id="showdownRows" class="grid" style="gap:6px"></div>

      <div class="divider"></div>
      <div id="sdWinnerWrap" class="badge" style="display:none"></div>

      <div class="sticky-bottom">
        <button class="btn ghost" id="btnCancelShowdown">Cancel</button>
        <button class="btn ghost nav-back" id="btnBackShowdown">River</button>
        <button class="btn nav-next" id="btnNextShowdown">Summary</button>
      </div>
    </div>
  </section>

  <!-- SUMMARY -->
  <section id="viewSummary" style="display:none" class="page">
    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Hand summary</h3>
        <button id="btnSummarySettings" class="iconbtn" aria-label="Report settings">⚙</button>
      </div>

      <div class="row" style="justify-content:space-between;align-items:center;margin:8px 0 10px">
        <button class="btn" id="btnSaveTop">Save hand</button>
        <div class="badge">Final pot: <span id="summaryPot">0</span></div>
      </div>

      <div id="summaryText" style="white-space:pre-wrap"></div>
      <div class="divider"></div>
      <div class="btnbar">
        <button class="btn" id="btnCopy">Copy text</button>
        <button class="btn ghost" id="btnAddComment">Add comment</button>
        <button class="btn ghost" id="btnCancelSummary">Cancel</button>
        <button class="btn ghost nav-back" id="btnBackToShowdown">Showdown</button>
      </div>
    </div>
  </section>

  <!-- PROFILES (legacy page still available) -->
  <section id="viewProfiles" style="display:none" class="page">
    <div class="panel">
      <h3>Player profiles</h3>
      <div id="profilesList" class="list"></div>
      <div class="divider"></div>
      <div class="row"><input id="profileName" placeholder="New profile name" /><button class="btn" id="btnAddProfile">Add</button><button class="btn ghost" id="btnBackFromProfiles">Done</button></div>
    </div>
  </section>

  <!-- NEW: Category page -->
  <section id="viewProfileCategory" style="display:none" class="page">
    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3 id="catTitle">Category</h3>
        <button class="btn ghost" id="btnBackFromCat">Back</button>
      </div>
      <div id="profilesListInCat" class="list" style="margin-top:8px"></div>
      <div class="divider"></div>
      <div class="row">
        <input id="newProfileNameInCat" placeholder="New profile name" />
        <button class="btn" id="btnAddProfileInCat">Add</button>
      </div>
    </div>
  </section>

  <!-- NEW: Profile detail page -->
  <section id="viewProfileDetail" style="display:none" class="page">
    <div class="panel has-sticky">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3 id="profTitle">Profile</h3>
        <button class="btn ghost" id="btnBackFromProfile">Back</button>
      </div>
      <div class="divider"></div>
      <div class="grid" style="grid-template-columns:1fr;gap:10px">
        <div>
          <div class="small muted">Name</div>
          <input id="profNameInput" />
        </div>
      </div>
      <div class="divider"></div>
      <h3>Hands played</h3>
      <div id="handsByProfile" class="list"></div>
      <div class="divider"></div>
      <h3>My notes</h3>
      <textarea id="profNotes"></textarea>
      <div class="sticky-bottom">
        <button class="btn" id="btnSaveProfile">Save</button>
      </div>
    </div>
  </section>

  <!-- MODALS -->
  <div class="modal" id="modalRaise">
    <div class="panel">
      <h3>Choose raise size</h3>
      <div id="raisePresetGrid" class="grid" style="grid-template-columns:repeat(3,minmax(0,1fr))">
        <button class="btn ghost" data-rx="2">2x</button>
        <button class="btn ghost" data-rx="2.5">2.5x</button>
        <button class="btn ghost" data-rx="3">3x</button>
        <button class="btn ghost" data-rx="3.5">3.5x</button>
        <button class="btn ghost" data-rx="4">4x</button>
        <button class="btn ghost" data-rx="5">5x</button>
      </div>
      <div class="divider"></div>
      <div class="grid" style="grid-template-columns:repeat(2,minmax(0,1fr))">
        <div>
          <div class="small muted">Custom (x BB)</div>
          <input type="number" step="0.01" min="0" inputmode="decimal" id="inpCustomX" />
        </div>
        <div>
          <div class="small muted">Custom amount (<span id="raiseCurSymbol">€</span>)</div>
          <input type="number" step="0.01" min="0" inputmode="decimal" id="inpCustomEUR" />
        </div>
      </div>
      <div class="sticky-bottom">
        <button class="btn ghost" id="btnCancelRaise">Cancel</button>
        <button class="btn nav-next" id="btnConfirmRaise">Confirm</button>
      </div>
    </div>
  </div>

  <div class="modal" id="modalBet">
    <div class="panel">
      <h3>Bet / Raise size</h3>
      <div class="row" style="justify-content:space-between;align-items:center;margin:6px 0 10px">
        <div class="badge">Pot before bet: <span id="betPotNow">€0</span></div>
        <div class="badge">Effective remaining: <span id="betEffRemain">€0</span></div>
      </div>
      <div class="row" style="align-items:center;gap:12px">
        <input type="range" min="0" max="250" value="50" id="betSlider" style="flex:1" />
        <div class="badge"><span id="betPctDisp">50</span>% pot</div>
      </div>
      <div class="grid" id="betPresetGrid" style="grid-template-columns:repeat(3,minmax(0,1fr))">
        <button class="btn ghost" data-bp="30">30%</button>
        <button class="btn ghost" data-bp="50">50%</button>
        <button class="btn ghost" data-bp="80">80%</button>
        <button class="btn ghost" data-bp="100">100%</button>
        <button class="btn ghost" data-bp="150">150%</button>
        <button class="btn ghost" data-bp="200">200%</button>
        <button class="btn ghost" data-bp="all">All-in</button>
      </div>
      <div class="divider"></div>
      <div class="grid" style="grid-template-columns:repeat(2,minmax(0,1fr))">
        <div><div class="small muted">Custom % of pot</div><input type="number" step="0.01" min="0" inputmode="decimal" id="inpCustomPct" placeholder="0.55 for 55%"/></div>
        <div><div class="small muted">Or custom amount (<span id="betCurSymbol">€</span>)</div><input type="number" step="0.01" min="0" inputmode="decimal" id="inpCustomBetEUR" /></div>
      </div>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalBet">Cancel</button>
        <button class="btn nav-next" id="btnConfirmBet">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Currency selector -->
  <div class="modal" id="modalCurrency">
    <div class="panel">
      <h3>Select currency</h3>
      <div class="grid" style="grid-template-columns:repeat(4,minmax(0,1fr))">
        <button class="btn ghost" data-cur="€">€ Euro</button>
        <button class="btn ghost" data-cur="$">$ USD</button>
      </div>
      <div class="sticky-bottom"><button class="btn ghost" data-close="modalCurrency">Close</button></div>
    </div>
  </div>

  <!-- Report settings -->
  <div class="modal" id="modalReportSettings">
    <div class="panel">
      <h3>Report settings</h3>
      <div class="grid" style="grid-template-columns:1fr;gap:10px">
        <label class="row" style="justify-content:space-between;align-items:center">
          <span class="small">Suits in text</span>
          <select id="selSuitsModeSettings" class="small" style="margin-left:8px;width:auto;background:transparent;border:1px solid var(--border);color:#e8ebff">
            <option value="symbols">Symbols (♠♥♦♣)</option>
            <option value="letters">Letters (s h d c)</option>
          </select>
        </label>
        <!-- NEW: Include player names in report -->
        <label class="row" style="justify-content:space-between;align-items:center">
          <span class="small">Include player names</span>
          <select id="selIncludeNamesSettings" class="small" style="margin-left:8px;width:auto;background:transparent;border:1px solid var(--border);color:#e8ebff">
            <option value="no">No</option>
            <option value="yes">Yes</option>
          </select>
        </label>
      </div>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalReportSettings">Close</button>
      </div>
    </div>
  </div>

  <!-- Card picker -->
  <div class="modal" id="modalCards">
    <div class="panel">
      <h3>Pick cards</h3>
      <div id="cardGrid"></div>
      <div class="sticky-bottom"><button class="btn nav-next" data-close="modalCards">Done</button></div>
    </div>
  </div>

  <!-- Edit player -->
  <div class="modal" id="modalEditPlayer">
    <div class="panel">
      <h3>Edit player</h3>
      <div class="grid" style="grid-template-columns:repeat(2,minmax(0,1fr))">
        <div><div class="small muted">Name</div><input id="inpPlayerName" /></div>
        <div><div class="small muted">Assign profile</div><select id="selPlayerProfile"></select></div>
      </div>
      <div class="divider"></div>
      <label class="row"><input type="checkbox" id="chkHero"/> Mark as Hero</label>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalEditPlayer">Cancel</button>
        <button class="btn nav-next" id="btnSavePlayer">Save</button>
      </div>
    </div>
  </div>

  <!-- Generic text/number edit -->
  <div class="modal" id="modalTextEdit">
    <div class="panel">
      <h3 id="textEditTitle">Edit</h3>
      <input id="textEditInput" />
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalTextEdit">Cancel</button>
        <button class="btn nav-next" id="btnTextEditSave">Save</button>
      </div>
    </div>
  </div>

  <!-- Dedicated blinds editor -->
  <div class="modal" id="modalBlinds">
    <div class="panel">
      <h3>Edit blinds</h3>
      <div class="grid" style="grid-template-columns:repeat(2,minmax(0,1fr));gap:10px">
        <div>
          <div class="small muted">SB</div>
          <input type="number" step="0.01" min="0" inputmode="decimal" id="inpSB" />
        </div>
        <div>
          <div class="small muted">BB</div>
          <input type="number" step="0.01" min="0" inputmode="decimal" id="inpBB" />
        </div>
      </div>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalBlinds">Cancel</button>
        <button class="btn nav-next" id="btnSaveBlinds">Save</button>
      </div>
    </div>
  </div>

  <div class="modal" id="modalTextarea">
    <div class="panel"><h3 id="txtareaTitle">Add text</h3><textarea id="txtarea"></textarea>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalTextarea">Cancel</button>
        <button class="btn nav-next" id="btnTextareaSave">Save</button>
      </div>
    </div>
  </div>

  <div class="modal" id="modalPickProfile">
    <div class="panel">
      <h3>Select profile</h3>
      <div id="pickProfilesBox" class="list"></div>
      <div class="sticky-bottom">
        <button class="btn ghost" data-close="modalPickProfile">Close</button>
        <button class="btn nav-next" id="btnGoProfiles">Manage profiles</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---- helpers / globals ---- */
const $=(s,r=document)=>r.querySelector(s), $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const fmt=n=>new Intl.NumberFormat(undefined,{maximumFractionDigits:2}).format(n);
const SUITS=["♠","♥","♦","♣"], RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const id=()=>Math.random().toString(36).slice(2,9);
function openModal(mid){const el=document.getElementById(mid); if(el) el.classList.add('open')}
function closeModal(mid){const el=document.getElementById(mid); if(el) el.classList.remove('open')}
function closeAllModals(){ $$('.modal.open').forEach(m=>m.classList.remove('open')); }
$$("[data-close]").forEach(b=>b.addEventListener('click',e=>closeModal(e.target.getAttribute('data-close'))));
function localSave(k,v){localStorage.setItem(k,JSON.stringify(v))}
function localLoad(k,d){try{const raw=localStorage.getItem(k);if(raw==null)return d;const v=JSON.parse(raw);return v==null?d:v}catch(e){return d}}
const DEFAULTS_KEY='hn_defaults_v1';
const LAST_RAISE_KEY='hn_last_raise_x_v1';
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

function markCurrencySelection(){
  $$('#modalCurrency [data-cur]').forEach(b=>{
    b.classList.toggle('selected', b.getAttribute('data-cur') === (hand?.currency));
  });
}

/* ==== App state ==== */
let app={
  hands:localLoad('hands',[]),
  profiles:localLoad('profiles',[]),
  profileCategories:localLoad('profileCategories',[])
};
ensureProfileCategories();
migrateProfilesShape();

let hand=null,currentStreet='flop';
let editing={raiseCtx:null,betCtx:null,playerIdx:null,textEdit:null,textarea:null,cardsFor:null,sdPos:null,boardTargetIndex:null};
let pendingRaisePos=null;
let uiState={prompted:{flop:false,turn:false,river:false}}; 
let currentCatId='all', currentProfileId=null;

init();

/* ------------------ init & nav ------------------ */
function init(){
  renderHandsList();
  renderCategoriesHome();
  buildCardPicker();
  // Players selector: 3..9 only
  $('#selPlayers').innerHTML = Array.from({length: 7}, (_,i)=>{
    const v = i + 3; // 3..9
    return `<option ${v===9?'selected':''} value="${v}">${v}</option>`;
  }).join('');
  bindGlobal();
}
function bindStreetMenu(){
  $$('#streetMenu [data-go]').forEach(b=>{
    b.onclick=()=>{
      const go=b.getAttribute('data-go');
      if(!hand && go!=='preflop') return;
      if(go==='preflop'){ show('viewPreflop'); }
      else if(go==='flop' || go==='turn' || go==='river'){ currentStreet=go; renderStreet(); show('viewStreet'); }
      else if(go==='show'){ showShowdown(); }
    };
  });
}
function setStreetMenuVisibility(id){
  const showMenu = (id==='viewPreflop'||id==='viewStreet'||id==='viewShowdown'||id==='viewSummary');
  const el = $('#streetMenu');
  if(el) el.style.display = showMenu ? 'block' : 'none';
}
function updateStreetMenuActive(){
  let activeKey=null;
  if($('#viewPreflop').style.display==='block') activeKey='preflop';
  else if($('#viewStreet').style.display==='block') activeKey=currentStreet;
  else if($('#viewShowdown').style.display==='block') activeKey='show';
  $$('#streetMenu [data-go]').forEach(b=>{
    b.classList.toggle('selected', b.getAttribute('data-go')===activeKey);
  });
}
function bindGlobal(){
  bindStreetMenu();

  const startNew=()=>newHand();
  if($('#btnNewFromListTop')) $('#btnNewFromListTop').onclick=startNew;

  if($('#btnBackFromProfiles')) $('#btnBackFromProfiles').onclick=()=>show('viewList');
  if($('#btnAddProfile')) $('#btnAddProfile').onclick=()=>addProfile('all','#profileName','#profilesList');

  // Categories on home
  $('#btnAddCategoryHome').onclick=addCategoryHome;

  // Category page nav
  $('#btnBackFromCat').onclick=()=>show('viewList');
  $('#btnAddProfileInCat').onclick=()=>addProfile(currentCatId,'#newProfileNameInCat','#profilesListInCat');

  // Profile detail nav
  $('#btnBackFromProfile').onclick=()=>openCategory(currentCatId);
  $('#btnSaveProfile').onclick=saveProfileDetail;

  // Prefop footer
  $('#btnCancelPF').onclick=()=>show('viewList');
  $('#btnFinishPF').onclick=finishPreflop;

  // Street footer
  $('#btnCancelStreet').onclick=()=>show('viewList');
  $('#btnBackStreet').onclick=backStreet;
  $('#btnNextStreet').onclick=nextStreet;

  // Board & hero cards
  $('#btnHeroCards').onclick=()=>{editing.cardsFor='hero';editing.sdPos=null;markCardSelections();updateCardPickerTitle();openModal('modalCards')};
  $('#btnEditBoard').onclick=()=>{
    editing.cardsFor=currentStreet;
    setBoardTargetIndexFor(currentStreet);
    editing.sdPos=null;
    markCardSelections();
    updateCardPickerTitle();
    openModal('modalCards')
  };
  $('#btnEditBoardSD').onclick=()=>{
    if((hand.board.flop||[]).some(c=>!c)){ editing.cardsFor='flop'; }
    else if(!hand.board.turn){ editing.cardsFor='turn'; }
    else { editing.cardsFor='river'; }
    setBoardTargetIndexFor(editing.cardsFor);
    editing.sdPos=null;
    markCardSelections(); 
    updateCardPickerTitle();
    openModal('modalCards');
  };

  // Summary actions
  $('#btnCopy').onclick=copySummary;

  /* CHANGED: after saving hand on Summary, go back to Home */
  $('#btnSaveTop').onclick=()=>{ saveHand(); show('viewList'); };

  /* CHANGED: open Add/Edit comments with existing text prefilled */
  $('#btnAddComment').onclick=()=> {
    const existing = (hand?.comments || []).join('\n\n');
    openTextarea(
      existing ? 'Edit comments' : 'Add comment',
      (t)=>{ hand.comments = t.trim() ? [t] : []; renderSummary(); },
      existing
    );
  };

  $('#btnCancelSummary').onclick=()=>show('viewList');
  $('#btnBackToShowdown').onclick=()=>{ showShowdown(); };
  $('#btnSummarySettings').onclick=()=>{
    $('#selSuitsModeSettings').value = hand?.suitsMode || 'symbols';
    // Prefill include-names select
    $('#selIncludeNamesSettings').value = hand?.reportIncludeNames ? 'yes' : 'no';
    openModal('modalReportSettings');
  };
  $('#selSuitsModeSettings').onchange=()=>{
    if(!hand) return;
    hand.suitsMode = $('#selSuitsModeSettings').value;
    renderSummary();
    // If card picker is open, refresh its header formatting too
    if($('#modalCards').classList.contains('open')) updateCardPickerTitle();
  };
  // NEW: Include player names toggle
  const includeSel = $('#selIncludeNamesSettings');
  if(includeSel){
    includeSel.onchange = ()=>{
      if(!hand) return;
      hand.reportIncludeNames = (includeSel.value === 'yes');
      renderSummary();
    };
  }

  // Postflop modal wiring
  const setSlider = (v)=>{
    $('#betSlider').value=v;
    $('#betPctDisp').textContent=v;
    const pct = +v/100;
    setPostflopFromPct(pct, /*fromSlider*/true);
  };
  $('#betSlider').oninput=()=> setSlider($('#betSlider').value);

  $$('#modalBet [data-bp]').forEach(b=>b.addEventListener('click',()=>{
    const v=b.getAttribute('data-bp');
    if(v==='all'){
      $('#inpCustomPct').value='all';
      const eff = editing.betCtx?.effRemain || 0;
      $('#inpCustomBetEUR').value = safeFmtCurrency(eff);
    }else{
      const pct = parseFloat(v)/100;
      setPostflopFromPct(pct, /*fromSliderBtn*/true);
    }
  }));
  $('#btnConfirmBet').onclick=confirmBet;

  $('#inpCustomPct').addEventListener('input',()=>{
    const t=$('#inpCustomPct').value.trim();
    if(t==='all'){ $('#inpCustomBetEUR').value = safeFmtCurrency(editing.betCtx?.effRemain || 0); return; }
    const p=parseFloat(t);
    if(!isNaN(p)) setPostflopFromPct(p,false);
  });
  $('#inpCustomBetEUR').addEventListener('input',()=>{
    const eur=parseFloat($('#inpCustomBetEUR').value);
    if(!isNaN(eur)) setPostflopFromEUR(eur,false);
  });

  // Raise modal presets
  $$('#modalRaise [data-rx]').forEach(b=>b.addEventListener('click',()=>{
    const mult=parseFloat(b.getAttribute('data-rx'));
    const ctx=editing.raiseCtx||{};
    let x = mult;
    if(ctx.isReraise && ctx.baseX>0) x = mult*ctx.baseX;
    setCustomRaiseFromX(x,true);
  }));
  $('#btnConfirmRaise').onclick=confirmRaise;
  $('#btnCancelRaise').onclick=()=>{pendingRaisePos=null;closeModal('modalRaise');renderPreflop()};

  // Custom X/EUR cross-sync (preflop)
  $('#inpCustomX').addEventListener('input',()=>{
    const x=parseFloat($('#inpCustomX').value);
    if(!isNaN(x)){ $('#inpCustomEUR').value = safeFmtCurrency(x*hand.blinds.bb); }
    highlightRaisePreset(x);
  });
  $('#inpCustomEUR').addEventListener('input',()=>{
    const eur=parseFloat($('#inpCustomEUR').value);
    if(!isNaN(eur)&&hand.blinds.bb>0){ $('#inpCustomX').value = (eur/hand.blinds.bb).toFixed(2).replace(/\.00$/,''); }
    const x=parseFloat($('#inpCustomX').value);
    highlightRaisePreset(x);
  });

  // Currency modal
  if($('#btnCurrency')) $('#btnCurrency').onclick=()=>{markCurrencySelection();openModal('modalCurrency')};
  $$('#modalCurrency [data-cur]').forEach(b=>b.addEventListener('click',()=>{
    const cur=b.getAttribute('data-cur');if(!hand)return;
    hand.currency=cur; if($('#btnCurrency')) $('#btnCurrency').textContent=cur;$('#curSymbol').textContent=cur;
    $('#raiseCurSymbol').textContent=cur; $('#betCurSymbol').textContent=cur;
    renderBasics();
    if($('#modalRaise').classList.contains('open')) updateRaiseButtons();
    if($('#modalBet').classList.contains('open')) { updateBetPresetLabels(); updateBetInfoBadges(); resyncPostflopCustomFields(); }
    if($('#viewShowdown').style.display==='block') renderShowdown();
    if($('#viewStreet').style.display==='block') renderStreet();
    if($('#viewSummary').style.display==='block') renderSummary();
    if($('#modalCards').classList.contains('open')) updateCardPickerTitle();
    closeModal('modalCurrency')
  }));

  if($('#selPlayers')) $('#selPlayers').onchange=()=>{if(!hand)return;setPlayers(+$('#selPlayers').value)};
  if($('#btnTextEditSave')) $('#btnTextEditSave').onclick=()=>{const v=$('#textEditInput').value;if(editing.textEdit)editing.textEdit(v);closeModal('modalTextEdit')};

  /* CHANGED: allow saving empty comment to clear notes */
  if($('#btnTextareaSave')) $('#btnTextareaSave').onclick=()=>{const v=$('#txtarea').value; if(editing.textarea)editing.textarea(v); closeModal('modalTextarea')};

  if($('#btnGoProfiles')) $('#btnGoProfiles').onclick=()=>{closeModal('modalPickProfile');renderProfiles();show('viewProfiles')};

  // Showdown footer
  $('#btnCancelShowdown').onclick=()=>show('viewList');
  $('#btnBackShowdown').onclick=()=>{ currentStreet='river'; renderStreet(); show('viewStreet'); };
  $('#btnNextShowdown').onclick=()=>{ renderSummary(); show('viewSummary'); };
}

/* ---------- editable popups (numeric-friendly) ---------- */
function textEdit(title,value,onSave){
  $('#textEditTitle').textContent=title;
  const inp=$('#textEditInput');
  inp.type='text';
  inp.removeAttribute('inputmode');
  inp.removeAttribute('step');
  inp.value=value;
  editing.textEdit=onSave;
  openModal('modalTextEdit');
  inp.focus(); inp.select();
}
function numberEdit(title,value,onSave,{step='0.01',min='0'}={}){
  $('#textEditTitle').textContent=title;
  const inp=$('#textEditInput');
  inp.type='number';
  inp.setAttribute('inputmode','decimal'); // mobile numeric keypad
  inp.setAttribute('step',step);
  inp.setAttribute('min',min);
  inp.value = (value==null || value==='') ? '' : String(value);
  editing.textEdit=(val)=>{
    const num=+val;
    if(!isNaN(num)) onSave(num);
  };
  openModal('modalTextEdit');
  inp.focus(); inp.select();
}
function openBlindsModal(){
  $('#inpSB').value = hand?.blinds?.sb ?? '';
  $('#inpBB').value = hand?.blinds?.bb ?? '';
  openModal('modalBlinds');
}
$('#btnSaveBlinds')?.addEventListener('click',()=>{
  const sb=parseFloat($('#inpSB').value);
  const bb=parseFloat($('#inpBB').value);
  if(!isNaN(sb) && !isNaN(bb) && bb>0){
    hand.blinds.sb=sb; hand.blinds.bb=bb;
    hand.effective.eur=hand.effective.bb*hand.blinds.bb;
    renderBasics();
    if($('#modalRaise').classList.contains('open')) updateRaiseButtons();
    if($('#modalBet').classList.contains('open')) { updateBetPresetLabels(); updateBetInfoBadges(); resyncPostflopCustomFields(); }
    if($('#viewStreet').style.display==='block'){ renderStreet(); }
    if($('#viewShowdown').style.display==='block'){ renderShowdown(); }
    if($('#viewSummary').style.display==='block'){ renderSummary(); }
    if($('#modalCards').classList.contains('open')) updateCardPickerTitle();
  }
  closeModal('modalBlinds');
});

function show(id){
  ['viewList','viewPreflop','viewStreet','viewShowdown','viewSummary','viewProfiles','viewProfileCategory','viewProfileDetail']
    .forEach(v=>document.getElementById(v).style.display=(v===id?'block':'none'));
  setStreetMenuVisibility(id);
  updateStreetMenuActive();
}

/* -------------- Home: hands -------------- */
function renderHandsList(){
  const box=$('#handsList'); box.innerHTML='';
  if(!app.hands.length){ box.innerHTML='<div class="item">No saved hands yet.</div>'; return; }
  app.hands.slice().reverse().forEach(h=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(h.summaryTitle||'Hand')}</strong><div class="meta">${escape(h.created||'')}</div></div><div class="row"><button class="btn ghost" data-open="${h.id}">Open</button><button class="btn" data-del="${h.id}" style="background:#ff6b6b">Delete</button></div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open'); const del=e.target.getAttribute('data-del');
      if(openId){ openSavedHand(openId); }
      if(del){ app.hands=app.hands.filter(x=>x.id!==del); localSave('hands',app.hands); renderHandsList(); }
    });
    box.appendChild(it);
  });
}
function openSavedHand(handId){
  hand=JSON.parse(JSON.stringify(app.hands.find(x=>x.id===handId)));
  pendingRaisePos=null;
  currentStreet='flop';
  uiState={prompted:{flop:false,turn:false,river:false}};
  renderSummary();
  show('viewSummary');
}

/* --------- Profiles: categories & profiles --------- */
function ensureProfileCategories(){
  if(!Array.isArray(app.profileCategories)) app.profileCategories=[];
  if(!app.profileCategories.some(c=>c.id==='all')){
    app.profileCategories.unshift({id:'all',name:'All'});
    localSave('profileCategories',app.profileCategories);
  }
}
function migrateProfilesShape(){
  let changed=false;
  app.profiles.forEach(p=>{
    if(!p.categoryId){ p.categoryId='all'; changed=true; }
    if(!Array.isArray(p.aliases)) { p.aliases=[]; changed=true; }
    if(typeof p.notes!=='string'){ p.notes=''; changed=true; }
  });
  if(changed) localSave('profiles',app.profiles);
}

/* ---------- New hand & defaults ---------- */
function newHand(){
  closeAllModals();
  editing={raiseCtx:null,betCtx:null,playerIdx:null,textEdit:null,textarea:null,cardsFor:null,sdPos:null,boardTargetIndex:null};
  pendingRaisePos=null;
  currentStreet='flop';
  uiState={prompted:{flop:false,turn:false,river:false}};
  const hcd=$('#heroCardsDisp'); if(hcd) hcd.textContent='';

  const def=localLoad(DEFAULTS_KEY,null);
  const defaultPlayersN = clamp(def?.playersN ?? 9, 3, 9);

  hand={
    id:id(), created:new Date().toLocaleString(),
    currency: def?.currency ?? '€',
    blinds: def?.blinds ? {sb:+def.blinds.sb, bb:+def.blinds.bb} : {sb:2,bb:4},
    playersN: defaultPlayersN,
    positions: defaultPositions(defaultPlayersN),
    players:[],
    profiles:{}, heroPos:null, heroCards:null, heroProfile: def?.heroProfile || '',
    straddlePos: null,
    effective: def?.effective ? {bb:+def.effective.bb, eur:+def.effective.eur} : {bb:100, eur:400},
    streets:{preflop:[], flop:[], turn:[], river:[]},
    board:{flop:[null,null,null], turn:null, river:null},
    comments:[], villainShowdown:'', suitsMode:'symbols',
    showdownHands:{}, /* pos -> [c1,c2] */
    reportIncludeNames:false /* NEW: report setting for including names */
  };

  // Players and hero seat
  hand.players=hand.positions.map((pos,i)=>({id:id(),pos,name:`Villain ${i+1}`,isHero:false,active:true}));

  let heroPos = (def && def.heroPos && hand.positions.includes(def.heroPos)) ? def.heroPos : hand.positions[0];
  let heroIdx = hand.positions.indexOf(heroPos);
  if(heroIdx<0) heroIdx=0;
  hand.players[heroIdx].isHero=true;
  hand.heroPos=hand.players[heroIdx].pos;

  if(def && def.seatMap){
    hand.players.forEach((p,i)=>{
      const savedName = def.seatMap[p.pos];
      if(savedName && typeof savedName==='string') p.name = savedName;
    });
  }

  renderBasics();
  if($('#selPlayers')) $('#selPlayers').value=hand.playersN;
  renderPreflop();
  show('viewPreflop');
}
function defaultPositions(n){
  if(n>=7) return ["UTG","UTG+1","UTG+2","MP","HJ","CO","BTN","SB","BB"].slice(9-n);
  if(n===6) return ["UTG","HJ","CO","BTN","SB","BB"];
  if(n===5) return ["HJ","CO","BTN","SB","BB"];
  if(n===4) return ["CO","BTN","SB","BB"];
  if(n===3) return ["BTN","SB","BB"];
  return ["BTN","SB","BB"];
}
function setPlayers(n){
  n = clamp(n,3,9);
  hand.playersN=n;
  hand.positions=defaultPositions(n);
  if(hand.straddlePos && !hand.positions.includes(hand.straddlePos)) hand.straddlePos=null;
  const heroPosPrev = hand.heroPos && hand.positions.includes(hand.heroPos) ? hand.heroPos : hand.positions[0];
  hand.players=hand.positions.map((pos,i)=>({id:id(),pos,name:`Villain ${i+1}`,isHero:false,active:true}));
  const heroIdx=hand.positions.indexOf(heroPosPrev);
  hand.players[heroIdx].isHero=true; hand.heroPos=hand.players[heroIdx].pos;
  renderPreflop()
}

/* Effective stacks sync */
function setEffectiveBB(v){const num=+v;if(isNaN(num))return;hand.effective.bb=num;hand.effective.eur=num*hand.blinds.bb}
function setEffectiveEUR(v){const num=+v;if(isNaN(num))return;hand.effective.eur=num;if(hand.blinds.bb>0)hand.effective.bb=num/hand.blinds.bb}

function renderBasics(){
  $('#lblBlinds').textContent=`${hand.currency}${hand.blinds.sb}/${hand.blinds.bb}`;
  // NEW: open numeric blinds modal
  $('#lblBlinds').onclick=()=>openBlindsModal();

  $('#lblStackBB').textContent=`${fmt(hand.effective.bb)}`;
  // numeric editor for BB
  $('#lblStackBB').onclick=()=>numberEdit('Effective Stack (bb)',hand.effective.bb,(v)=>{setEffectiveBB(v);renderBasics();if($('#viewShowdown').style.display==='block') renderShowdown();},{step:'0.1',min:'0'});

  $('#curSymbol').textContent=hand.currency||'€';
  $('#lblStackEUR').textContent=`${hand.currency}${fmt(hand.effective.eur)}`;
  // numeric editor for € effective
  $('#lblStackEUR').onclick=()=>numberEdit(`Effective Stack (${hand.currency})`,hand.effective.eur,(v)=>{setEffectiveEUR(v);renderBasics();if($('#viewShowdown').style.display==='block') renderShowdown();},{step:'0.01',min:'0'});

  if($('#btnCurrency')) $('#btnCurrency').textContent=hand.currency||'€';
  $('#raiseCurSymbol').textContent=hand.currency||'€';
  $('#betCurSymbol').textContent=hand.currency||'€';
}

/* ---------- Order helpers ---------- */
function preflopOrderPositions(){
  if(hand?.straddlePos){
    const i=hand.positions.indexOf(hand.straddlePos);
    if(i>=0){
      return hand.positions.slice(i+1).concat(hand.positions.slice(0,i+1));
    }
  }
  return hand.positions.slice();
}
function preflopIndex(pos){return preflopOrderPositions().indexOf(pos)}
function lastActionFor(street,pl){const arr=hand.streets[street];for(let i=arr.length-1;i>=0;i--){if(arr[i].player===pl.pos)return arr[i]}return null}
/* NEW: first action helper to preserve initial limp display */
function firstActionFor(street, pl){
  const arr = hand.streets[street];
  for(let i=0;i<arr.length;i++){
    if(arr[i].player === pl.pos) return arr[i];
  }
  return null;
}
/* FIXED: return the actual index (was returning the action object) */
function lastActionIndexFor(street,pos){
  const arr=hand.streets[street];
  for(let i=arr.length-1;i>=0;i--){
    if(arr[i].player===pos) return i;
  }
  return -1;
}
function postflopOrderPositions(){const i=hand.positions.indexOf('SB');if(i<0)return hand.positions.slice();return hand.positions.slice(i).concat(hand.positions.slice(0,i))}
function postflopOrderActivePlayers(){return postflopOrderPositions().map(pos=>hand.players.find(p=>p.pos===pos)).filter(p=>p&&p.active)}
function raiseCountBeforeSeatByPos(pos){let c=0;const acts=hand.streets.preflop;for(let i=0;i<acts.length;i++){const a=acts[i];if(a.type==='raise'&&preflopIndex(a.player)<preflopIndex(pos))c++}return c}

/* ---------- Hero switch ---------- */
function setHeroByIndex(newIdx){
  const n=hand.players.length;
  const oldIdx=hand.players.findIndex(p=>p.isHero);
  if(oldIdx===newIdx){return}
  if(oldIdx!==-1){
    const villains=[];
    for(let k=1;k<n;k++){const idx=(oldIdx+k)%n;villains.push(hand.players[idx].name)}
    for(let k=1;k<n;k++){const idx=(newIdx+k)%n;hand.players[idx].name=villains[k-1]}
  }
  hand.players.forEach(p=>p.isHero=false);
  hand.players[newIdx].isHero=true;
  hand.heroPos=hand.players[newIdx].pos;
}

/* Utility: if first-to-act had straddle on, turning it off before acting */
function wrapAutoUnstraddle(pl, handler){
  return ()=>{
    if(hand.straddlePos === pl.pos){
      if(hand.streets.preflop.length>0){
        hand.streets.preflop = [];
        hand.players.forEach(pp=>pp.active=true);
      }
      hand.straddlePos = null;
      renderPreflop();
    }
    handler();
  };
}

/* ---------- Preflop UI ---------- */
function renderPreflop(){
  const wrap=$('#preflopRows'); wrap.innerHTML='';
  const firstPos = hand.positions[0]; // first to act if no straddle
  hand.players.forEach((pl,i)=>{
    const row=document.createElement('div'); row.className='pos-row';
    const displayName = pl.isHero ? (hand.heroProfile || 'Hero') : pl.name;

    row.innerHTML=
      `<div class="pos-info">
         <div class="pos-label" data-posbtn="${i}">${escape(pl.pos)}${pl.isHero?' <span class="is-hero">· Hero</span>':''}</div>
         <div class="name-tap" data-pickprof="${i}">${escape(displayName)}</div>
       </div>
       <div class="actions" data-actions="${i}"></div>`;
    wrap.appendChild(row);

    const bar=row.querySelector('[data-actions]');
    const act=lastActionFor('preflop',pl);
    const rc=raiseCountBeforeSeatByPos(pl.pos);
    const raiseLabel=rc===0?'Raise':(rc===1?'3-bet':(rc+2)+'-bet');
    const raiseNote=(act&&act.type==='raise')?('to '+(act.x?fmt(act.x)+'x':hand.currency+fmt(act.eur||0))):'';
    const raiseSelected=!!(act&&act.type==='raise')||(pendingRaisePos===pl.pos);

    const isFirstSeat = (pl.pos===firstPos);
    const isStraddler = (hand.straddlePos === pl.pos);

    // Straddle control (pure toggle)
    if(isFirstSeat){
      const btnWrap = actionWrap('Straddle 2BB',()=>{
        const togglingOff = (hand.straddlePos===pl.pos);
        if(hand.streets.preflop.length>0){
          hand.streets.preflop = [];
          hand.players.forEach(pp=>pp.active=true);
        }
        hand.straddlePos = togglingOff ? null : pl.pos;
        renderPreflop();
      }, isStraddler /*selected*/);
      bar.appendChild(btnWrap);
    }

    // Buttons in unopened pot / general
    if(rc===0 && (pl.pos==='BB' && !hand.straddlePos)){
      bar.appendChild(actionWrap('Limp',()=>doAction('preflop',pl,'check',{}, {respond:false}),!!(act&&act.type==='check'))); // in BB unopened = check
      bar.appendChild(actionWrap('Raise',()=>openRaise(pl),raiseSelected,raiseNote));
    }else if(rc===0){
      const mk = (label, fn, selected, note)=>{
        const handler = (isFirstSeat && isStraddler) ? wrapAutoUnstraddle(pl, fn) : fn;
        return actionWrap(label, handler, selected, note);
      };
      const first = firstActionFor('preflop', pl);
      const initialWasLimp = !!(first && first.type === 'limp');

      bar.appendChild(mk('Fold',()=>doAction('preflop',pl,'fold'),!!(act&&act.type==='fold')));
      // Keep “Limp” visually selected if the player's initial action was a limp
      bar.appendChild(mk('Limp',()=>doAction('preflop',pl,'limp'), initialWasLimp));
      bar.appendChild(mk(raiseLabel,()=>openRaise(pl),raiseSelected,raiseNote));
    }else{
      bar.appendChild(actionWrap('Fold',()=>doAction('preflop',pl,'fold'),!!(act&&act.type==='fold')));
      bar.appendChild(actionWrap('Call',()=>doAction('preflop',pl,'call'),!!(act&&act.type==='call')));
      bar.appendChild(actionWrap(raiseLabel,()=>openRaise(pl),raiseSelected,raiseNote));
    }

    row.querySelector('[data-posbtn]').onclick=()=>{ setHeroByIndex(i); renderPreflop(); };
    row.querySelector('[data-pickprof]').onclick=()=>openProfilePicker(i);
  });
  renderQueue();
}

function openProfilePicker(idx){
  const box=$('#pickProfilesBox');
  box.innerHTML='';
  const isHeroSeat = !!hand.players[idx].isHero;

  if(!app.profiles.length){
    const note=document.createElement('div');note.className='item';
    note.textContent='No profiles yet. Use “Manage profiles” to add some.';box.appendChild(note);
  }else{
    app.profiles.forEach(p=>{
      const b=document.createElement('button');
      b.className='btn ghost'; b.textContent=p.name;
      b.onclick=()=>{ if(isHeroSeat){hand.heroProfile=p.name} else {hand.players[idx].name=p.name}
        closeModal('modalPickProfile'); renderPreflop(); };
      box.appendChild(b);
    });
    const clear=document.createElement('button');
    clear.className='btn ghost'; clear.textContent='Clear name';
    clear.onclick=()=>{ if(isHeroSeat){hand.heroProfile=''} else {hand.players[idx].name=`Villain ${idx+1}`}
      closeModal('modalPickProfile'); renderPreflop(); };
    box.appendChild(clear);
  }
  openModal('modalPickProfile');
}

/* ---------- Preflop queues ---------- */
function computeQueueGroup(){
  const info = lastRaiseInfo();
  if(!info) return [];

  const acts = hand.streets.preflop;

  // Who had money in already before this raise?
  const inPotBefore = new Set(['SB','BB']);
  if(hand.straddlePos) inPotBefore.add(hand.straddlePos);
  for(let i=0;i<=info.lastIdx;i++){
    const a = acts[i];
    if(a.type !== 'fold') inPotBefore.add(a.player);
  }

  const order = preflopOrderPositions();
  const orderFromRaiser = order.slice(info.raiserIdx+1).concat(order.slice(0,info.raiserIdx+1));

  // First action after the last raise for each player
  const afterActs = acts.slice(info.lastIdx+1);
  const firstAfter = {};
  for(const a of afterActs){
    if(!firstAfter[a.player]) firstAfter[a.player] = a;
  }

  return orderFromRaiser
    .map(pos => hand.players.find(p=>p.pos===pos))
    .filter(p => p && inPotBefore.has(p.pos) && p.pos !== info.raiserPos) // include even if folded later
    .map(p => ({ 
      pl: p, 
      response: firstAfter[p.pos] || null 
    }));
}

function computeQueue(){
  const acts=hand.streets.preflop;
  const info = lastRaiseInfo();
  if(!info) return [];

  const inPotBefore=new Set(['SB','BB']);
  if(hand.straddlePos) inPotBefore.add(hand.straddlePos);
  for(let i=0;i<=info.lastIdx;i++){
    const a=acts[i];
    if(a.type!=='fold') inPotBefore.add(a.player);
  }

  const respondedAfter=new Set();
  for(let i=info.lastIdx+1;i<acts.length;i++){respondedAfter.add(acts[i].player)}

  const order=preflopOrderPositions();
  const orderFromRaiser = order.slice(info.raiserIdx+1).concat(order.slice(0,info.raiserIdx+1));

  return orderFromRaiser
  const bb=hand.blinds.bb,sb=hand.blinds.sb;
  let base=sb+bb;
  if(hand.straddlePos)base+=2*bb;
  return base
}
function potAtEnd(street){const order=['preflop','flop','turn','river'];let total=startPot();for(let i=0;i<order.length;i++){const s=order[i];total+=streetAdded(s);if(s===street)break}return total}
function potBeforeAction(street){return(street==='preflop'?startPot():potAtEnd(prevStreet(street)))+streetAdded(street,true)}
function prevStreet(s){return s==='flop'?'preflop':s==='turn'?'flop':'turn'}
function streetAdded(street){
  const acts=hand.streets[street];
  const bb=hand.blinds.bb, sb=hand.blinds.sb;
  const contrib={};

  if(street==='preflop'){
    contrib['SB']=sb;
    contrib['BB']=bb;
    if(hand.straddlePos) contrib[hand.straddlePos]=2*bb;
  }

  let toCall=(street==='preflop'?(hand.straddlePos?2*bb:bb):0);
  let currentBet=0,added=0;
  for(let i=0;i<acts.length;i++){
    const a=acts[i],who=a.player;
    if(contrib[who]==null)contrib[who]=0;

    if(street==='preflop'){
      if(a.type==='limp'||a.type==='call'){
        const need=toCall-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
      }else if(a.type==='raise'){
        const raiseTo=a.x?a.x*bb:(a.eur||toCall);
        const need=raiseTo-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
        toCall=raiseTo
      }else if(a.type==='check'){
        // no money added
      }
    }else{
      if(a.type==='bet'){
        const potNow=(street==='flop'?potAtEnd('preflop'):street==='turn'?potAtEnd('flop'):potAtEnd('turn'))+added;
        const amount=(a.pct==='all')?potNow:(a.pct?potNow*a.pct:a.eur||0);
        const need=amount-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
        currentBet=amount;
      }else if(a.type==='call'){
        const need=currentBet-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
      }
    }
  }
  return added
}
function contribTotalsUpTo(street){
  const order=['preflop','flop','turn','river'];
  const upto=order.indexOf(street);
  const bb=hand.blinds.bb, sb=hand.blinds.sb;
  const totals={};
  const add=(who,amt)=>{totals[who]=(totals[who]||0)+amt};
  add('SB',sb); add('BB',bb); if(hand.straddlePos) add(hand.straddlePos,2*bb);

  for(let si=0; si<=upto; si++){
    const s=order[si]; const acts=hand.streets[s];
    const streetContrib={};
    if(s==='preflop'){ streetContrib['SB']=sb; streetContrib['BB']=bb; if(hand.straddlePos) streetContrib[hand.straddlePos]=2*bb; }
    let toCall=(s==='preflop'?(hand.straddlePos?2*bb:bb):0);
    let currentBet=0;
    let added=0;
    const basePot = (s==='preflop') ? (sb+bb+(hand.straddlePos?2*bb:0)) : potAtEnd(order[si-1]);
    for(let i=0;i<acts.length;i++){
      const a=acts[i], who=a.player;
      if(streetContrib[who]==null) streetContrib[who]=0;
      if(totals[who]==null) totals[who]=0;

      if(s==='preflop'){
        if(a.type==='limp'||a.type==='call'){
          const need=toCall-streetContrib[who];
          if(need>0){ streetContrib[who]+=need; totals[who]+=need; added+=need; }
        }else if(a.type==='raise'){
          const raiseTo=a.x?a.x*bb:(a.eur||toCall);
          const need=raiseTo-streetContrib[who];
          if(need>0){ streetContrib[who]+=need; totals[who]+=need; added+=need; }
          toCall=raiseTo;
        }
      }else{
        if(a.type==='bet'){
          const potNow=basePot+added;
          const amount=(a.pct==='all')?potNow:(a.pct?potNow*a.pct:a.eur||0);
          const need=amount-streetContrib[who];
          if(need>0){ streetContrib[who]+=need; totals[who]+=need; added+=need; }
          currentBet=amount;
        }else if(a.type==='call'){
          const need=currentBet-streetContrib[who];
          if(need>0){ streetContrib[who]+=need; totals[who]+=need; added+=need; }
        }
      }
    }
  }
  return totals;
}
function minEffectiveRemaining(street=currentStreet){
  const totals=contribTotalsUpTo(street);
  let min=Infinity;
  const eff=hand.effective.eur||0;
  hand.players.filter(p=>p.active).forEach(p=>{
    const spent=totals[p.pos]||0;
    const remain=Math.max(0, eff-spent);
    if(remain<min) min=remain;
  });
  if(min===Infinity) min=eff;
  return min;
}


/* ---- UI Rendering: General ---- */
function renderBasics(){
  $('#lblBlinds').textContent=`${hand.currency}${hand.blinds.sb}/${hand.blinds.bb}`;
  // NEW: open numeric blinds modal
  $('#lblBlinds').onclick=()=>openBlindsModal();

  $('#lblStackBB').textContent=`${fmt(hand.effective.bb)}`;
  // numeric editor for BB
  $('#lblStackBB').onclick=()=>numberEdit('Effective Stack (bb)',hand.effective.bb,(v)=>{setEffectiveBB(v);renderBasics();if($('#viewShowdown').style.display==='block') renderShowdown();},{step:'0.1',min:'0'});

  $('#curSymbol').textContent=hand.currency||'€';
  $('#lblStackEUR').textContent=`${hand.currency}${fmt(hand.effective.eur)}`;
  // numeric editor for € effective
  $('#lblStackEUR').onclick=()=>numberEdit(`Effective Stack (${hand.currency})`,hand.effective.eur,(v)=>{setEffectiveEUR(v);renderBasics();if($('#viewShowdown').style.display==='block') renderShowdown();},{step:'0.01',min:'0'});

  if($('#btnCurrency')) $('#btnCurrency').textContent=hand.currency||'€';
  $('#raiseCurSymbol').textContent=hand.currency||'€';
  $('#betCurSymbol').textContent=hand.currency||'€';
}
function btn(label,fn){const b=document.createElement('button');b.className='btn ghost small';b.textContent=label;b.onclick=fn;return b}
function actionWrap(label,onClick,selected,note){const w=document.createElement('div');w.className='actwrap';const b=btn(label,onClick);if(selected)b.classList.add('selected');w.appendChild(b);if(note){const n=document.createElement('div');n.className='btn-note';n.textContent=note;w.appendChild(n)}return w}


/* ---- UI Rendering: Home ---- */
function renderHandsList(){
  const box=$('#handsList'); box.innerHTML='';
  if(!app.hands.length){ box.innerHTML='<div class="item">No saved hands yet.</div>'; return; }
  app.hands.slice().reverse().forEach(h=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(h.summaryTitle||'Hand')}</strong><div class="meta">${escape(h.created||'')}</div></div><div class="row"><button class="btn ghost" data-open="${h.id}">Open</button><button class="btn" data-del="${h.id}" style="background:#ff6b6b">Delete</button></div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open'); const del=e.target.getAttribute('data-del');
      if(openId){ openSavedHand(openId); }
      if(del){ app.hands=app.hands.filter(x=>x.id!==del); localSave('hands',app.hands); renderHandsList(); }
    });
    box.appendChild(it);
  });
}
function openSavedHand(handId){
  hand=JSON.parse(JSON.stringify(app.hands.find(x=>x.id===handId)));
  pendingRaisePos=null;
  currentStreet='flop';
  uiState={prompted:{flop:false,turn:false,river:false}};
  renderSummary();
  show('viewSummary');
}
function renderCategoriesHome(){
  const box=$('#categoriesListHome'); box.innerHTML='';
  const cats=[...app.profileCategories];
  cats.forEach(cat=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(cat.name)}</strong></div>
      <div class="row">
        <button class="btn ghost" data-open="${cat.id}">Open</button>
        ${cat.id!=='all'?`<button class="btn" data-del="${cat.id}" style="background:#ff6b6b">Delete</button>`:''}
      </div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open');
      const delId=e.target.getAttribute('data-del');
      if(openId){ openCategory(openId); }
      if(delId){ deleteCategory(delId); }
    });
    box.appendChild(it);
  });
}
function openCategory(catId){
  currentCatId = catId || 'all';
  renderProfilesInCategory();
  show('viewProfileCategory');
}
function renderProfilesInCategory(){
  const cat = app.profileCategories.find(c=>c.id===currentCatId) || {id:'all',name:'All'};
  $('#catTitle').textContent = `Category: ${cat.name}`;
  const box=$('#profilesListInCat'); box.innerHTML='';
  const list = app.profiles.filter(p=> (currentCatId==='all' ? true : p.categoryId===currentCatId));
  if(!list.length){ box.innerHTML='<div class="item">No profiles in this category.</div>'; return; }
  list.forEach(p=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(p.name)}</strong><div class="meta">${cat.name}</div></div>
      <div class="row">
        <button class="btn ghost" data-open="${p.id}">Open</button>
        <button class="btn" data-del="${p.id}" style="background:#ff6b6b">Delete</button>
      </div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open');
      const delId=e.target.getAttribute('data-del');
      if(openId){ openProfile(openId); }
      if(delId){ deleteProfile(delId); }
    });
    box.appendChild(it);
  });
}
function addProfile(catId, inputSel, listSel){
  const input=$(inputSel);
  const name=input.value.trim();
  if(!name) return;
  app.profiles.push({id:id(),name,categoryId:catId||'all',notes:'',aliases:[]});
  localSave('profiles',app.profiles);
  input.value='';
  if(listSel==='#profilesListInCat') renderProfilesInCategory();
  renderProfiles();
  renderCategoriesHome();
}
function deleteProfile(pid){
  app.profiles = app.profiles.filter(p=>p.id!==pid);
  localSave('profiles',app.profiles);
  renderProfilesInCategory();
  renderProfiles();
}
function openProfile(pid){
  currentProfileId = pid;
  renderProfileDetail();
  show('viewProfileDetail');
}
function saveProfileDetail(){
  const p = app.profiles.find(x=>x.id===currentProfileId);
  if(!p) return;
  const newName = $('#profNameInput').value.trim() || p.name;
  if(newName !== p.name){
    if(!p.aliases.includes(p.name)) p.aliases.push(p.name);
    p.name = newName;
  }
  p.notes = $('#profNotes').value;
  localSave('profiles',app.profiles);
  renderProfilesInCategory();
  renderCategoriesHome();
}
function renderProfileDetail(){
  const p = app.profiles.find(x=>x.id===currentProfileId);
  if(!p){ $('#profTitle').textContent='Profile'; $('#profNameInput').value=''; $('#profNotes').value=''; $('#handsByProfile').innerHTML=''; return; }
  $('#profTitle').textContent = `Profile: ${p.name}`;
  $('#profNameInput').value = p.name;
  $('#profNotes').value = p.notes || '';

  const namesToMatch = new Set([p.name, ...(p.aliases||[])].filter(Boolean));
  const hands = app.hands.filter(h=>{
    if(namesToMatch.has(h.heroProfile)) return true;
    if(Array.isArray(h.players) && h.players.some(pl=> namesToMatch.has(pl.name))) return true;
    return false;
  });
  const box=$('#handsByProfile'); box.innerHTML='';
  if(!hands.length){ box.innerHTML='<div class="item">No hands for this player yet.</div>'; }
  else{
    hands.slice().reverse().forEach(h=>{
      const it=document.createElement('div'); it.className='item';
      it.innerHTML=`<div><strong>${escape(h.summaryTitle||'Hand')}</strong><div class="meta">${escape(h.created||'')}</div></div>
                    <div class="row"><button class="btn ghost" data-open="${h.id}">Open</button></div>`;
      it.addEventListener('click',e=>{
        const openId=e.target.getAttribute('data-open');
        if(openId){ openSavedHand(openId); }
      });
      box.appendChild(it);
    });
  }
}
function renderProfiles(){
  const box=$('#profilesList'); if(!box)return;
  box.innerHTML='';
  if(!app.profiles.length){box.innerHTML='<div class="item">No profiles yet.</div>';return}
  app.profiles.forEach(p=>{
    const cat = app.profileCategories.find(c=>c.id===p.categoryId)?.name || 'All';
    const it=document.createElement('div');it.className='item';
    it.innerHTML=`<div><strong>${escape(p.name)}</strong><div class="meta">${escape(cat)}</div></div>
                  <div class="row">
                    <button class="btn ghost" data-open="${p.id}">Open</button>
                    <button class="btn" data-del="${p.id}" style="background:#ff6b6b">Delete</button>
                  </div>`;
    it.addEventListener('click',e=>{
      const del=e.target.getAttribute('data-del');
      const open=e.target.getAttribute('data-open');
      if(del){app.profiles=app.profiles.filter(x=>x.id!==del);localSave('profiles',app.profiles);renderProfiles();renderCategoriesHome()}
      if(open){ openProfile(open); }
    });
    box.appendChild(it)
  })
}
function openProfilePicker(idx){
  const box=$('#pickProfilesBox');
  box.innerHTML='';
  const isHeroSeat = !!hand.players[idx].isHero;

  if(!app.profiles.length){
    const note=document.createElement('div');note.className='item';
    note.textContent='No profiles yet. Use “Manage profiles” to add some.';box.appendChild(note);
  }else{
    app.profiles.forEach(p=>{
      const b=document.createElement('button');
      b.className='btn ghost'; b.textContent=p.name;
      b.onclick=()=>{ if(isHeroSeat){hand.heroProfile=p.name} else {hand.players[idx].name=p.name}
        closeModal('modalPickProfile'); renderPreflop(); };
      box.appendChild(b);
    });
    const clear=document.createElement('button');
    clear.className='btn ghost'; clear.textContent='Clear name';
    clear.onclick=()=>{ if(isHeroSeat){hand.heroProfile=''} else {hand.players[idx].name=`Villain ${idx+1}`}
      closeModal('modalPickProfile'); renderPreflop(); };
    box.appendChild(clear);
  }
  openModal('modalPickProfile');
}


/* ---- App Start ---- */
ensureProfileCategories();
migrateProfilesShape();
init();
</script>
</body>
</html>
    if(remain<min) min=remain;
  });
  if(min===Infinity) min=eff;
  return min;
}

function openBet(pl,isRaise,opts={}){
  editing.betCtx={street:currentStreet,id:pl.id,isRaise:!!isRaise,respond:!!opts.respond};
  const potRef = potBeforeAction(currentStreet);
  const effRemain = minEffectiveRemaining(currentStreet);
  editing.betCtx.potRef = potRef;
  editing.betCtx.effRemain = effRemain;

  updateBetInfoBadges();
  updateBetPresetLabels();
  updateStreetNavLabels();

  const defaultPct=isRaise?0.80:0.50;
  setPostflopFromPct(defaultPct,true);

  pendingRaisePos=pl.pos;
  openModal('modalBet')
}
function updateBetInfoBadges(){
  const cur=hand.currency||'€';
  $('#betPotNow').textContent = `${cur}${fmt(editing.betCtx?.potRef||0)}`;
  $('#betEffRemain').textContent = `${cur}${fmt(editing.betCtx?.effRemain||0)}`;
  $('#betCurSymbol').textContent=cur;
}
function updateBetPresetLabels(){
  const cur=hand.currency||'€';
  const pot=editing.betCtx?.potRef||0;
  const eff=editing.betCtx?.effRemain||0;
  $$('#modalBet [data-bp]').forEach(b=>{
    const v=b.getAttribute('data-bp');
    if(v==='all'){
      b.textContent=`All-in (${cur}${fmt(eff)})`;
    }else{
      const pct=parseFloat(v)/100;
      const amt=pot*pct;
      b.textContent=`${v}% (${cur}${fmt(amt)})`;
    }
  });
}

/* Keep fields in sync (postflop) */
function setPostflopFromPct(pct,alsoSetSlider){
  if(isNaN(pct)) return;
  const pot=editing.betCtx?.potRef||0;
  const eur=pot*pct;
  $('#inpCustomPct').value = (Math.round(pct*100)/100).toFixed(2);
  $('#inpCustomBetEUR').value = safeFmtCurrency(eur);
  if(alsoSetSlider){
    const sliderV=Math.max(0,Math.min(250,Math.round(pct*100)));
    $('#betSlider').value=sliderV;
    $('#betPctDisp').textContent=String(sliderV);
  }
}
function setPostflopFromEUR(eur,alsoSetSlider){
  const pot=editing.betCtx?.potRef||0;
  const pct = pot>0 ? eur/pot : 0;
  setPostflopFromPct(pct, alsoSetSlider);
}
function resyncPostflopCustomFields(){
  const t=$('#inpCustomPct').value.trim();
  if(t==='all'){
    $('#inpCustomBetEUR').value = safeFmtCurrency(editing.betCtx?.effRemain||0);
  }else{
    const p=parseFloat(t);
    if(!isNaN(p)) setPostflopFromPct(p,false);
  }
}

/* ---------- Bet confirm ---------- */
function confirmBet(){
  const ctx=editing.betCtx||{respond:false};
  const pl=findById(ctx.id);if(!pl)return;
  let pctRaw=$('#inpCustomPct').value.trim();
  let eur=parseFloat($('#inpCustomBetEUR').value);
  if(pctRaw===''){ pctRaw=(+$('#betSlider').value/100).toString() }
  if(pctRaw==='all'){
    doAction(currentStreet,pl,'bet',{pct:'all',isRaise:ctx.isRaise},{respond:ctx.respond})
  }else if(!isNaN(parseFloat(pctRaw))){
    doAction(currentStreet,pl,'bet',{pct:parseFloat(pctRaw),isRaise:ctx.isRaise},{respond:ctx.respond})
  }else if(!isNaN(eur)){
    doAction(currentStreet,pl,'bet',{eur,isRaise:ctx.isRaise},{respond:ctx.respond})
  }
  pendingRaisePos=null;closeModal('modalBet')
}
function findById(idv){return hand.players.find(p=>p.id===idv)}

/* Core action */
function doAction(street,pl,type,payload={},opts={}){const respond=!!opts.respond;
  if(street==='preflop'){
    if(!respond){
      const hadPrior=hand.streets.preflop.some(a=>a.player===pl.pos);
      hand.streets.preflop=hand.streets.preflop.filter(a=>a.player!==pl.pos);
      if(hadPrior)clearActionsAfterSeat(pl);
      autoFoldSkippedBefore(pl)
    }
  }else{
    if(!respond){
      const hadPrior=hand.streets[street].some(a=>a.player===pl.pos);
      hand.streets[street]=hand.streets[street].filter(a=>!a.player||a.player!==pl.pos);
      if(hadPrior)clearActionsAfterSeatOnStreet(pl,street);
      if(type==='check'||type==='bet')autoCheckSkippedBeforeStreet(pl,street)
    }
  }
  hand.streets[street].push({player:pl.pos,playerName:pLName(pl),type:type,...(payload||{})});
  if(type==='fold')pl.active=false;
  if(street==='preflop'){renderPreflop();maybeAdvancePreflop()}else{renderStreet();maybeAdvanceStreet(street)}
}
function pLName(p){return p.isHero ? (hand.heroProfile || 'Hero') : p.name}

/* Preflop auto-advance */
function lastRaiseInfo(){
  const acts=hand.streets.preflop;
  for(let i=acts.length-1;i>=0;i--){
    if(acts[i].type==='raise'){
      const pos=acts[i].player;
      return{lastIdx:i,raiserPos:pos,raiserIdx:preflopIndex(pos)}
    }
  }return null
}
function playersAfterRaiserOwe(){
  const info=lastRaiseInfo();if(!info)return[];
  const acts=hand.streets.preflop;
  const responded=new Set(acts.slice(info.lastIdx+1).map(a=>a.player));
  const order=preflopOrderPositions();
  const afterSeats=order.slice(info.raiserIdx+1);
  return afterSeats.map(pos=>hand.players.find(p=>p.pos===pos)).filter(p=>p&&p.active&&!responded.has(p.pos))
}
function lastToActNoRaisePos(){return hand.straddlePos ? hand.straddlePos : 'BB'}
function maybeAdvancePreflop(){
  const alive=hand.players.filter(p=>p.active).length;
  if(alive<=1){renderSummary();show('viewSummary');return}
  const acts=hand.streets.preflop;
  const hasRaise=acts.some(a=>a.type==='raise');
  if(hasRaise){
    const q=computeQueue();const after=playersAfterRaiserOwe();
    if(q.length===0&&after.length===0){currentStreet='flop';renderStreet();show('viewStreet')}
  }else{
    const lastPos=lastToActNoRaisePos();const lastAct=acts.find(a=>a.player===lastPos);
    if(lastAct&&lastAct.type==='check'){currentStreet='flop';renderStreet();show('viewStreet')}
  }
}

/* Postflop auto-advance */
function maybeAdvanceStreet(street){
  const alive=hand.players.filter(p=>p.active).length;
  if(alive<=1){renderSummary();show('viewSummary');return}
  const info=lastBetInfo(street);
  if(!info){
    const allActed=postflopOrderActivePlayers().every(p=>lastActionIndexFor(street,p.pos)>=0);
    if(allActed){
      if(street==='flop'){currentStreet='turn';renderStreet();show('viewStreet')}
      else if(street==='turn'){currentStreet='river';renderStreet();show('viewStreet')}
      else{ showShowdown(); }
    }
    return
  }
  const owed=computePostQueue(street);
  if(owed.length===0){
    if(street==='flop'){currentStreet='turn';renderStreet();show('viewStreet')}
    else if(street==='turn'){currentStreet='river';renderStreet();show('viewStreet')}
    else{ showShowdown(); }
  }
}
function finishPreflop(){const alive=hand.players.filter(p=>p.active);if(alive.length<2){renderSummary();show('viewSummary');return}currentStreet='flop';renderStreet();show('viewStreet')}
function backStreet(){if(currentStreet==='flop'){show('viewPreflop');return}if(currentStreet==='turn'){currentStreet='flop';renderStreet()}else if(currentStreet==='river'){currentStreet='turn';renderStreet()}}
function nextStreet(){if(currentStreet==='flop'){currentStreet='turn';renderStreet()}else if(currentStreet==='turn'){currentStreet='river';renderStreet()}else{ showShowdown(); }}

/* Update street footer button labels per street */
function updateStreetNavLabels(){
  if(!$('#viewStreet') || $('#viewStreet').style.display==='none') return;
  const back=$('#btnBackStreet'), next=$('#btnNextStreet');
  if(currentStreet==='flop'){ back.textContent='Preflop'; next.textContent='Turn'; }
  else if(currentStreet==='turn'){ back.textContent='Flop'; next.textContent='River'; }
  else if(currentStreet==='river'){ back.textContent='Turn'; next.textContent='Showdown'; }
}

/* Auto-open card picker */
function maybePromptBoardFor(street){
  if($('#modalCards').classList.contains('open'))return;
  if(uiState.prompted[street])return;
  if(street==='flop'){
    const need=(hand.board.flop||[]).some(c=>!c);
    if(need){editing.cardsFor='flop';setBoardTargetIndexFor('flop');markCardSelections();updateCardPickerTitle();openModal('modalCards');uiState.prompted.flop=true}
  }else if(street==='turn'){
    if(!hand.board.turn){editing.cardsFor='turn';markCardSelections();updateCardPickerTitle();openModal('modalCards');uiState.prompted.turn=true}
  }else if(street==='river'){
    if(!hand.board.river){editing.cardsFor='river';markCardSelections();updateCardPickerTitle();openModal('modalCards');uiState.prompted.river=true}
  }
}
function renderStreet(){
  $('#streetTitle').textContent=currentStreet[0].toUpperCase()+currentStreet.slice(1);
  $('#potDisp').textContent=hand.currency+fmt(potBeforeAction(currentStreet));
  updateStreetNavLabels();
  /* NEW: keep the top street menu highlight in sync on every render */
  updateStreetMenuActive();

  const bc=$('#boardCards'); bc.innerHTML='';
  const show=c=>{const d=document.createElement('div');d.className='card';d.textContent=c||'—';d.style.cursor='default';return d};
  const b=hand.board;
  if(currentStreet==='flop'){bc.appendChild(show(b.flop[0]));bc.appendChild(show(b.flop[1]));bc.appendChild(show(b.flop[2]))}
  if(currentStreet==='turn'){[0,1,2].forEach(i=>bc.appendChild(show(b.flop[i])));bc.appendChild(show(b.turn))}
  if(currentStreet==='river'){[0,1,2].forEach(i=>bc.appendChild(show(b.flop[i])));bc.appendChild(show(b.turn));bc.appendChild(show(b.river))}
  const betInfo=lastBetInfo(currentStreet), betExists=!!betInfo;
  const wrap=$('#streetRows'); wrap.innerHTML='';
  postflopOrderActivePlayers().forEach(pl=>{
    const row=document.createElement('div'); row.className='pos-row';
    const last=lastActionFor(currentStreet,pl);
    const note=(last&&last.type==='bet')?(last.pct==='all'?'all-in':(last.pct?(Math.round(last.pct*100))+'% pot':hand.currency+fmt(last.eur||0))):'';
    const disp = pl.isHero ? (hand.heroProfile || 'Hero') : pl.name;
    row.innerHTML=`<div class="pos-info"><div class="pos-label" data-posbtn>${pl.pos}${pl.isHero?' <span class="is-hero">· Hero</span>':''}</div><div class="name-tap">${escape(disp)}</div></div><div class="actions"></div>`;
    const bar=row.querySelector('.actions');
    if(!betExists){
      bar.appendChild(actionWrap('Check',()=>doAction(currentStreet,pl,'check'),!!(last&&last.type==='check')));
      bar.appendChild(actionWrap('Bet',()=>openBet(pl,false),!!(last&&last.type==='bet'&&!last.isRaise),note))
    }else{
      const idx=lastActionIndexFor(currentStreet,pl.pos);
      if(pl.pos===betInfo.pos){
        bar.appendChild(actionWrap('Bet',()=>openBet(pl,false),!!(last&&last.type==='bet'&&!last.isRaise)||(pendingRaisePos===pl.pos),note))
      }else if(idx===-1){
        const st=document.createElement('div');st.className='status';st.textContent='owes action below';bar.appendChild(st)
      }else if(idx<betInfo.idx){
        if(last&&last.type==='check'){bar.appendChild(actionWrap('Check',()=>doAction(currentStreet,pl,'check'),true))}
        else{bar.appendChild(actionWrap('Bet',()=>openBet(pl,true),false,note))}
      }else{
        if(last&&last.type==='fold'){bar.appendChild(actionWrap('Fold',()=>doAction(currentStreet,pl,'fold'),true))}
        else if(last&&last.type==='call'){bar.appendChild(actionWrap('Call',()=>doAction(currentStreet,pl,'call'),true))}
        else if(last&&last.type==='bet'&&last.isRaise){bar.appendChild(actionWrap('Raise',()=>openBet(pl,true),true,note))}
        else {bar.appendChild(actionWrap('Raise',()=>openBet(pl,true),false,note))}
      }
    }
    wrap.appendChild(row);
  });
  renderPostQueue(currentStreet); maybePromptBoardFor(currentStreet);
}

/* ---------- SHOWDOWN ---------- */
function showShowdown(){ renderShowdown(); show('viewShowdown'); }
function getBoardCards(){
  const b=hand.board; const out=[];
  if(b.flop) out.push(...b.flop.filter(Boolean));
  if(b.turn) out.push(b.turn);
  if(b.river) out.push(b.river);
  return out.filter(Boolean);
}
function getShowdownHandForPos(pos){
  const sd=hand.showdownHands?.[pos];
  if(sd && sd.length===2) return sd.slice();
  if(hand.heroPos===pos && hand.heroCards && hand.heroCards.length===2) return hand.heroCards.slice();
  return sd && sd.length ? sd.slice() : null;
}
function renderShowdown(){
  $('#sdPot').textContent = `${hand.currency}${fmt(potAtEnd('river'))}`;
  $('#sdEff').textContent = `${hand.currency}${fmt(minEffectiveRemaining('river'))}`;

  const sdbc=$('#sdBoardCards'); sdbc.innerHTML='';
  const showc=c=>{const d=document.createElement('div');d.className='card';d.textContent=c||'—';d.style.cursor='default';return d};
  const b=hand.board;
  [0,1,2].forEach(i=>sdbc.appendChild(showc(b.flop[i])));
  sdbc.appendChild(showc(b.turn));
  sdbc.appendChild(showc(b.river));

  const rows=$('#showdownRows'); rows.innerHTML='';
  const active=hand.players.filter(p=>p.active);

  active.forEach(pl=>{
    const dispName = pl.isHero ? (hand.heroProfile || 'Hero') : pl.name;
    const cur = getShowdownHandForPos(pl.pos) || [];
    const c1 = cur[0] || '—', c2 = cur[1] || '—';

    const row=document.createElement('div');
    row.className='sd-row';
    row.innerHTML=
      `<div class="pos-info">
         <div class="pos-label">${pl.pos}${pl.isHero?' <span class="is-hero">· Hero</span>':''}</div>
         <div class="name-tap">${escape(dispName)}</div>
       </div>
       <div class="sd-hand">
         <div class="card" data-sdslot="1">${c1}</div>
         <div class="card" data-sdslot="2">${c2}</div>
       </div>`;
    rows.appendChild(row);

    row.querySelectorAll('.sd-hand .card').forEach(el=>{
      el.onclick=()=>{
        editing.cardsFor='sd';
        editing.sdPos=pl.pos;
        markCardSelections();
        updateCardPickerTitle();
        openModal('modalCards');
      };
    });
  });

  renderShowdownWinners();
}
function renderShowdownWinners(){
  const wrap=$('#sdWinnerWrap');
  const result=computeWinners();
  if(!result || !result.ready){
    wrap.style.display='none';
    return;
  }
  const names=result.winners.map(w=>{
    const pl=hand.players.find(p=>p.pos===w.pos);
    const disp = pl?.isHero ? (hand.heroProfile || 'Hero') : (pl?.name || w.pos);
    return `${w.pos} (${escape(disp)})`;
  }).join(', ');
  wrap.textContent = `Winner${result.winners.length>1?'s':''}: ${names} — ${result.bestName}`;
  wrap.style.display='inline-flex';
}

/* Hand evaluation (for showdown winner names) */
const RANK_MAP={A:14,K:13,Q:12,J:11,T:10,9:9,8:8,7:7,6:6,5:5,4:4,3:3,2:2};
function parseCard(c){if(!c) return null; const suit=c.slice(-1); const r=c.slice(0,-1); const rv=RANK_MAP[r]||null; return rv?{r:rv,s:suit,raw:c}:null;}
function evaluate7(cards){
  const parsed=cards.map(parseCard).filter(Boolean);
  if(parsed.length<5) return null;
  const bySuit={}; parsed.forEach(c=>{(bySuit[c.s]||(bySuit[c.s]=[])).push(c)});
  const counts={}; parsed.forEach(c=>{counts[c.r]=(counts[c.r]||0)+1});
  const ranks=Object.keys(counts).map(n=>+n).sort((a,b)=>b-a);
  const sorted=parsed.slice().sort((a,b)=>b.r-a.r);
  const toRanks=(arr)=>arr.map(c=>c.r).sort((a,b)=>b-a);

  function straightHigh(uniqueRanks){
    const arr=uniqueRanks.slice().sort((a,b)=>b-a);
    const wheel = [5,4,3,2,14];
    let run=1, best=null;
    for(let i=0;i<arr.length-1;i++){
      if(arr[i]-1===arr[i+1]){ run++; if(run>=5){ best=arr[i+1]+4; break; } }
      else if(arr[i]!==arr[i+1]) run=1;
    }
    if(!best){
      const set=new Set(uniqueRanks);
      if(wheel.every(v=>set.has(v))) best=5;
    }
    return best;
  }

  for(const s of Object.keys(bySuit)){
    const suited=bySuit[s].map(c=>c.r).filter((v,i,a)=>a.indexOf(v)===i).sort((a,b)=>b-a);
    if(suited.length>=5){
      const hi=straightHigh(suited);
      if(hi){ return {score:[8,hi], name:`Straight flush to ${hi===14?'A':hi}`}; }
    }
  }
  const quads=ranks.find(r=>counts[r]===4);
  if(quads){
    const kicker=sorted.find(c=>c.r!==quads).r;
    return {score:[7,quads,kicker], name:`Four of a kind ${valName(quads)}`};
  }
  const trips=ranks.filter(r=>counts[r]===3);
  const pairs=ranks.filter(r=>counts[r]===2);
  if(trips.length){
    if(trips.length>=2){
      return {score:[6,trips[0],trips[1]], name:`Full house ${valName(trips[0])} over ${valName(trips[1])}`};
    }
    if(pairs.length){
      return {score:[6,trips[0],pairs[0]], name:`Full house ${valName(trips[0])} over ${valName(pairs[0])}`};
    }
  }
  for(const s of Object.keys(bySuit)){
    if(bySuit[s].length>=5){
      const top5=toRanks(bySuit[s]).slice(0,5);
      return {score:[5,...top5], name:`Flush (${top5.map(valName).join('-')})`};
    }
  }
  const hi=straightHigh(ranks.slice());
  if(hi){ return {score:[4,hi], name:`Straight to ${hi===14?'A':hi}`}; }
  if(trips.length){
    const kickers=ranks.filter(r=>r!==trips[0]).slice(0,2);
    return {score:[3,trips[0],...kickers], name:`Three of a kind ${valName(trips[0])}`};
  }
  if(pairs.length>=2){
    const top2=pairs.slice(0,2);
    const kicker=ranks.find(r=>!top2.includes(r));
    return {score:[2,top2[0],top2[1],kicker||0], name:`Two pair ${valName(top2[0])} & ${valName(top2[1])}`};
  }
  if(pairs.length===1){
    const kickers=ranks.filter(r=>r!==pairs[0]).slice(0,3);
    return {score:[1,pairs[0],...kickers], name:`Pair of ${valName(pairs[0])}`};
  }
  const top5=ranks.slice(0,5);
  return {score:[0,...top5], name:`High card ${valName(top5[0])}`};

  function valName(v){return v===14?'A':v===13?'K':v===12?'Q':v===11?'J':v===10?'T':String(v)}
}
function compareScore(a,b){
  for(let i=0;i<Math.max(a.length,b.length);i++){
    const av=a[i]??-1, bv=b[i]??-1;
    if(av>bv) return 1;
    if(av<bv) return -1;
  }
  return 0;
}
function computeWinners(){
  const board=getBoardCards();
  if(board.length<5) return {ready:false};
  const contenders=hand.players.filter(p=>p.active).map(p=>{
    const hole=getShowdownHandForPos(p.pos);
    if(!hole || hole.length<2) return null;
    const evald=evaluate7(board.concat(hole));
    return {pos:p.pos, eval:evald};
  }).filter(Boolean);
  if(!contenders.length) return {ready:false};
  let best=null, winners=[];
  contenders.forEach(c=>{
    if(!best || compareScore(c.eval.score,best.eval.score)>0){
      best=c; winners=[c];
    }else if(compareScore(c.eval.score,best.eval.score)===0){
      winners.push(c);
    }
  });
  if(!best) return {ready:false};
  return {ready:true, winners:winners.map(w=>({pos:w.pos})), bestName:best.eval.name};
}

/* ---- Card picker ---- */
function allUsedCards(){
  return []
    .concat(hand.heroCards||[])
    .concat(hand.board.flop||[])
    .concat(hand.board.turn||[])
    .concat(hand.board.river||[])
    .concat(Object.values(hand.showdownHands||{}).flat())
    .filter(Boolean);
}
function usedSetExcludingCurrentContext(){
  const used=allUsedCards().slice();
  let exclude=[];
  if(editing.cardsFor==='hero'){
    exclude=(hand.heroCards||[]).slice();
  }else if(editing.cardsFor==='flop'){
    exclude=(hand.board.flop||[]).filter(Boolean);
  }else if(editing.cardsFor==='turn'){
    exclude=hand.board.turn?[hand.board.turn]:[];
  }else if(editing.cardsFor==='river'){
    exclude=hand.board.river?[hand.board.river]:[];
  }else if(editing.cardsFor==='sd' && editing.sdPos){
    exclude=(getShowdownHandForPos(editing.sdPos)||[]).slice();
  }
  exclude.forEach(card=>{
    const idx=used.indexOf(card);
    if(idx>-1) used.splice(idx,1);
  });
  return new Set(used);
}
function buildCardPicker(){
  const grid=$('#cardGrid');grid.innerHTML='';
  RANKS.forEach(r=>SUITS.forEach(s=>{
    const b=document.createElement('button');
    b.className='btn ghost small';
    b.textContent=r+s;
    b.onclick=()=>{ if(!b.classList.contains('unavailable')) pickCard(r+s) };
    grid.appendChild(b)
  }));
}
function markCardSelections(){
  const selected=new Set();
  if(editing.cardsFor==='hero'){
    (hand.heroCards||[]).forEach(c=>selected.add(c));
  }else if(editing.cardsFor==='flop'){
    (hand.board.flop||[]).filter(Boolean).forEach(c=>selected.add(c));
  }else if(editing.cardsFor==='turn'){
    if(hand.board.turn)selected.add(hand.board.turn)
  }else if(editing.cardsFor==='river'){
    if(hand.board.river)selected.add(hand.board.river)
  }else if(editing.cardsFor==='sd' && editing.sdPos){
    const cur=getShowdownHandForPos(editing.sdPos)||[];
    cur.forEach(c=>selected.add(c));
  }

  const locked=usedSetExcludingCurrentContext();
  $$('#cardGrid button').forEach(b=>{
    const card=b.textContent;
    b.classList.toggle('selected', selected.has(card));
    const unavailable = locked.has(card);
    b.classList.toggle('unavailable', unavailable);
  });

  // keep title synced if user navigated back to picker after changes elsewhere
  updateCardPickerTitle();
}
function isShowdownVisible(){ return $('#viewShowdown').style.display==='block'; }
function updateShowdownIfVisible(){ if(isShowdownVisible()) renderShowdown(); }
function setBoardTargetIndexFor(street){
  if(street==='flop'){
    const i=(hand.board.flop||[]).findIndex(x=>!x);
    editing.boardTargetIndex = (i===-1?0:i);
  }else{
    editing.boardTargetIndex = null;
  }
}

/* NEW: context-aware card picker title */
function suitsConvert(str){
  if(!str) return '';
  if(hand.suitsMode==='letters'){
    const map={"♠":"s","♥":"h","♦":"d","♣":"c"};
    return str.replace(/[♠♥♦♣]/g,m=>map[m]);
  }
  return str;
}
function fmtCardForTitle(c){ return c ? suitsConvert(c) : '??'; }
function currentBoardForTitle(target){
  const b=hand.board;
  const flop = [fmtCardForTitle(b.flop[0]), fmtCardForTitle(b.flop[1]), fmtCardForTitle(b.flop[2])];
  if(target==='flop'){
    return flop.join(' ');
  }else if(target==='turn'){
    const t = fmtCardForTitle(b.turn);
    return [...flop, t].join(' ');
  }else if(target==='river' || target==='sd'){
    const t = fmtCardForTitle(b.turn);
    const r = fmtCardForTitle(b.river);
    return [...flop, t, r].join(' ');
  }
  return flop.join(' ');
}
function heroHoleForTitle(){
  const hc = hand.heroCards;
  if(Array.isArray(hc) && hc.length===2) return suitsConvert(hc.join(' '));
  return '??';
}
function showdownHoleForPosTitle(pos){
  const arr = getShowdownHandForPos(pos);
  if(arr && arr.length===2) return suitsConvert(arr.join(' '));
  return '??';
}
function updateCardPickerTitle(){
  const h3 = $('#modalCards h3');
  if(!h3) return;
  let title='Pick cards';

  if(editing.cardsFor==='flop' || editing.cardsFor==='turn' || editing.cardsFor==='river'){
    const streetName = editing.cardsFor.charAt(0).toUpperCase()+editing.cardsFor.slice(1);
    const boardTxt = currentBoardForTitle(editing.cardsFor);
    const heroTxt = heroHoleForTitle();
    title = `${streetName} - Board: ${boardTxt} - Hero: ${heroTxt}`;
  }else if(editing.cardsFor==='sd'){
    const boardTxt = currentBoardForTitle('sd');
    const who = (editing.sdPos===hand.heroPos) ? 'Hero' : (editing.sdPos || '—');
    const hole = showdownHoleForPosTitle(editing.sdPos);
    title = `Show - Board: ${boardTxt} - ${who}: ${hole}`;
  }
  h3.textContent = title;
}

function pickCard(card){
  if(editing.cardsFor==='hero'){
    if(!hand.heroCards)hand.heroCards=[];
    if(hand.heroCards.length>=2)hand.heroCards.shift();
    const locked=usedSetExcludingCurrentContext();
    if(locked.has(card)) return;
    if(!hand.heroCards.includes(card)) hand.heroCards.push(card);
    $('#heroCardsDisp').textContent=hand.heroCards.join(' ');
    hand.showdownHands = hand.showdownHands || {};
    if(hand.heroPos){
      if(hand.heroCards.length===2) hand.showdownHands[hand.heroPos]=hand.heroCards.slice();
      else delete hand.showdownHands[hand.heroPos];
    }
    markCardSelections();
    updateCardPickerTitle();
    updateShowdownIfVisible();
  }else if(editing.cardsFor==='sd' && editing.sdPos){
    hand.showdownHands = hand.showdownHands || {};
    const arr = (hand.showdownHands[editing.sdPos] || []).slice();
    const locked=usedSetExcludingCurrentContext();
    if(locked.has(card)) return;
    if(arr.length>=2) arr.shift();
    if(!arr.includes(card)) arr.push(card);
    hand.showdownHands[editing.sdPos]=arr;
    if(editing.sdPos===hand.heroPos){
      hand.heroCards = arr.slice();
      $('#heroCardsDisp').textContent=(hand.heroCards||[]).join(' ');
    }
    markCardSelections();
    updateCardPickerTitle();
    renderShowdown();
  }else{
    const locked=usedSetExcludingCurrentContext();
    if(locked.has(card)) return;

    if(editing.cardsFor==='flop'){
      const iEmpty=hand.board.flop.findIndex(x=>!x);
      let idx = (iEmpty>-1)?iEmpty : (editing.boardTargetIndex!=null?editing.boardTargetIndex:0);
      const otherIdx=[0,1,2].filter(k=>k!==idx);
      if(otherIdx.some(k=>hand.board.flop[k]===card)) return;
      hand.board.flop[idx]=card;
      editing.boardTargetIndex = (idx+1)%3;
    }else if(editing.cardsFor==='turn'){
      if(card===hand.board.flop[0]||card===hand.board.flop[1]||card===hand.board.flop[2]) return;
      hand.board.turn=card
    }else if(editing.cardsFor==='river'){
      if(card===hand.board.flop[0]||card===hand.board.flop[1]||card===hand.board.flop[2]||card===hand.board.turn) return;
      hand.board.river=card
    }
    renderStreet();markCardSelections();updateCardPickerTitle();updateShowdownIfVisible();
  }
}

/* Pot math */
function startPot(){
  const bb=hand.blinds.bb,sb=hand.blinds.sb;
  let base=sb+bb;
  if(hand.straddlePos)base+=2*bb;
  return base
}
function potAtEnd(street){const order=['preflop','flop','turn','river'];let total=startPot();for(let i=0;i<order.length;i++){const s=order[i];total+=streetAdded(s);if(s===street)break}return total}
function potBeforeAction(street){return(street==='preflop'?startPot():potAtEnd(prevStreet(street)))+streetAdded(street,true)}
function prevStreet(s){return s==='flop'?'preflop':s==='turn'?'flop':'turn'}
function streetAdded(street){
  const acts=hand.streets[street];
  const bb=hand.blinds.bb, sb=hand.blinds.sb;
  const contrib={};

  if(street==='preflop'){
    contrib['SB']=sb;
    contrib['BB']=bb;
    if(hand.straddlePos) contrib[hand.straddlePos]=2*bb;
  }

  let toCall=(street==='preflop'?(hand.straddlePos?2*bb:bb):0);
  let currentBet=0,added=0;
  for(let i=0;i<acts.length;i++){
    const a=acts[i],who=a.player;
    if(contrib[who]==null)contrib[who]=0;

    if(street==='preflop'){
      if(a.type==='limp'||a.type==='call'){
        const need=toCall-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
      }else if(a.type==='raise'){
        const raiseTo=a.x?a.x*bb:(a.eur||toCall);
        const need=raiseTo-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
        toCall=raiseTo
      }else if(a.type==='check'){
        // no money added
      }
    }else{
      if(a.type==='bet'){
        const potNow=(street==='flop'?potAtEnd('preflop'):street==='turn'?potAtEnd('flop'):potAtEnd('turn'))+added;
        const amount=(a.pct==='all')?potNow:(a.pct?potNow*a.pct:a.eur||0);
        const need=amount-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
        currentBet=amount
      }else if(a.type==='call'){
        const need=currentBet-contrib[who];
        if(need>0){added+=need;contrib[who]+=need}
      }
    }
  }
  return added
}

/* ---------- Summary text ---------- */
function renderSummary(){
  const txt=buildSummaryText();
  $('#summaryText').textContent=txt;
  const finalPot = potAtEnd('river')||potAtEnd('turn')||potAtEnd('flop')||potAtEnd('preflop');
  $('#summaryPot').textContent=hand.currency+fmt(finalPot);
}

/* Helpers for summary formatting already defined: suitsConvert() above… */
function formatCards(arr){
  if(!arr || arr.length!==2) return '';
  return suitsConvert(arr.join(' '));
}
function boardStr(mode){
  const s=hand.suitsMode||'symbols';
  const convert=c=>{if(!c)return'';if(s==='symbols')return c;const map={"♠":"s","♥":"h","♦":"d","♣":"c"};return c.replace(/[♠♥♦♣]/g,m=>map[m])};
  const flop=(hand.board.flop||[]).filter(Boolean).map(convert).join(' ');
  const turn=hand.board.turn?convert(hand.board.turn):''
  const river=hand.board.river?convert(hand.board.river):'';
  if(mode==='flop')return flop;
  if(mode==='turn')return[flop,turn].filter(Boolean).join(' ');
  if(mode==='river')return[flop,turn,river].filter(Boolean).join(' ');
  return flop
}

/* NEW: seat display honoring reportIncludeNames */
function dispSeat(pos){
  const include = !!hand?.reportIncludeNames;
  if(include){
    if(pos===hand.heroPos) return `${pos} (Hero)`;
    const pl = hand.players.find(p=>p.pos===pos);
    const nm = pl && !pl.isHero ? (pl.name || '') : '';
    return nm ? `${pos} (${nm})` : `${pos}`;
  }else{
    return `${pos}${pos===hand.heroPos?' (Hero)':''}`;
  }
}

function formatPreflopActions(){
  const bb=hand.blinds.bb, sb=hand.blinds.sb, cur=hand.currency||'€';
  const acts=hand.streets.preflop||[];
  const lines=[];

  // Show straddle as first action
  if(hand.straddlePos){
    lines.push(`• ${dispSeat(hand.straddlePos)} posts straddle 2×BB (${cur}${fmt(2*bb)})`);
  }

  const contrib={ SB:sb, BB:bb };
  if(hand.straddlePos) contrib[hand.straddlePos]=2*bb;
  let toCall = hand.straddlePos ? 2*bb : bb;
  let raiseCount=0;
  acts.forEach(a=>{
    const who=a.player;
    const label = dispSeat(who);
    if(a.type==='fold'){ lines.push(`• ${label} folds`); }
    else if(a.type==='limp'){
      const need=Math.max(0,toCall-(contrib[who]||0));
      contrib[who]=(contrib[who]||0)+need;
      lines.push(`• ${label} limps${need?` ${cur}${fmt(need)}`:''}`);
    }else if(a.type==='call'){
      const need=Math.max(0,toCall-(contrib[who]||0));
      contrib[who]=(contrib[who]||0)+need;
      lines.push(`• ${label} calls ${cur}${fmt(need)}`);
    }else if(a.type==='check'){
      lines.push(`• ${label} checks`);
    }else if(a.type==='raise'){
      raiseCount++;
      const raiseTo=a.x?a.x*bb:(a.eur||toCall);
      const need=Math.max(0,raiseTo-(contrib[who]||0));
      contrib[who]=(contrib[who]||0)+need;
      const x = bb>0 ? (raiseTo/bb) : 0;
      const verb = (raiseCount===1)?'opens to':(raiseCount===2)?'3-bets to':((raiseCount+1)+'-bets to');
      lines.push(`• ${label} ${verb} ${trimZeros(x)}x (${cur}${fmt(raiseTo)})`);
      toCall=raiseTo;
    }
  });
  return lines;
}
function formatPostflopActions(street){
  const cur=hand.currency||'€';
  const acts=hand.streets[street]||[];
  const lines=[];
  const basePot = (street==='flop')?potAtEnd('preflop'):street==='turn'?potAtEnd('flop'):potAtEnd('turn');
  let pot=basePot;
  const contrib={}; // on this street
  let currentBet=0;
  acts.forEach(a=>{
    const who=a.player;
    const label = dispSeat(who);
    if(a.type==='check'){
      lines.push(`• ${label} checks`);
    }else if(a.type==='bet'){
      let amount = a.pct==='all' ? pot : (a.pct? pot*a.pct : (a.eur||0));
      amount = Math.max(0,amount);
      const need= amount - (contrib[who]||0);
      contrib[who]=(contrib[who]||0)+Math.max(0,need);
      pot+=Math.max(0,need);
      currentBet=amount;
      if(a.pct==='all'){
        lines.push(`• ${label} jams (all-in)`);
      }else{
        lines.push(`• ${label} ${a.isRaise?'raises to':'bets'} ${cur}${fmt(amount)}`);
      }
    }else if(a.type==='call'){
      const need=Math.max(0,currentBet - (contrib[who]||0));
      contrib[who]=(contrib[who]||0)+need;
      pot+=need;
      lines.push(`• ${label} calls ${cur}${fmt(need)}`);
    }else if(a.type==='fold'){
      lines.push(`• ${label} folds`);
    }
  });
  return lines;
}
function resultLine(){
  const cur=hand.currency||'€';
  const finalPot = potAtEnd('river')||potAtEnd('turn')||potAtEnd('flop')||potAtEnd('preflop');
  const active = hand.players.filter(p=>p.active);
  const cw = computeWinners();
  if(cw && cw.ready){
    const names = cw.winners.map(w=>dispSeat(w.pos)).join(', ');
    return `${names} win${cw.winners.length>1?'':'s'} ${cur}${fmt(finalPot)}`;
  }
  if(active.length===1){
    const p=active[0];
    return `${dispSeat(p.pos)} wins ${cur}${fmt(finalPot)}`;
  }
  return `(Undetermined — no showdown cards for all players)`;
}
function showdownList(){
  const out=[];
  hand.players.forEach(pl=>{
    const cards=getShowdownHandForPos(pl.pos);
    if(cards && cards.length===2){
      out.push(`• ${dispSeat(pl.pos)} — ${suitsConvert(cards.join(' '))}`);
    }
  });
  return out;
}

function buildSummaryText(){
  const cur=hand.currency;
  const sb=hand.blinds.sb, bb=hand.blinds.bb;
  const lines=[];
  lines.push(`NLH — ${cur}${fmt(sb)}/${fmt(bb)} (${hand.playersN}-handed) | Effective: ${fmt(hand.effective.bb)}bb (${cur}${fmt(hand.effective.eur)})`);
  // Hero header: always show (Hero) per spec (never show hero name here)
  const heroCardsStr = formatCards(hand.heroCards) || '—';
  const heroStr = hand.heroPos ? `${hand.heroPos} (Hero) — ${heroCardsStr}` : '—';
  lines.push(`Hero: ${heroStr}`);
  const straddleLabel = hand.straddlePos ? `${dispSeat(hand.straddlePos).replace(/ \(.+?\)$/, '')} (yes)` : `${(hand.positions[0]||'—')} (no)`;
  lines.push(`Blinds: SB ${cur}${fmt(sb)} / BB ${cur}${fmt(bb)} | Straddle: ${straddleLabel}`);

  // Preflop
  lines.push('');
  const preBase = sb+bb;
  const preBaseBB = bb? preBase/bb : 0;
  lines.push(`Preflop  (Pot ${cur}${fmt(preBase)} / ${fmt(preBaseBB)}bb; +${cur}${fmt(2*bb)} if straddle)`);
  lines.push(...formatPreflopActions());
  lines.push(`Pot to Flop: ${cur}${fmt(potAtEnd('preflop'))}`);

  // Flop
  if(hand.board.flop && hand.board.flop.some(Boolean)){
    lines.push('');
    lines.push(`Flop — ${boardStr('flop')}  (Pot ${cur}${fmt(potAtEnd('preflop'))})`);
    lines.push(...formatPostflopActions('flop'));
    lines.push(`Pot to Turn: ${cur}${fmt(potAtEnd('flop'))}`);
  }

  // Turn
  if(hand.board.turn){
    lines.push('');
    lines.push(`Turn — ${boardStr('turn')}  (Pot ${cur}${fmt(potAtEnd('flop'))})`);
    lines.push(...formatPostflopActions('turn'));
    lines.push(`Pot to River: ${cur}${fmt(potAtEnd('turn'))}`);
  }

  // River
  if(hand.board.river){
    lines.push('');
    lines.push(`River — ${boardStr('river')}  (Pot ${cur}${fmt(potAtEnd('turn'))})`);
    lines.push(...formatPostflopActions('river'));
  }

  // Result
  lines.push('');
  lines.push(`Result: ${resultLine()}`);

  // Showdown
  lines.push('');
  lines.push('Showdown');
  const sd=showdownList();
  if(sd.length) lines.push(...sd); else lines.push('• (No cards shown)');

  // Notes
  if(hand.comments&&hand.comments.length){
    lines.push('');
    lines.push('Notes: '+hand.comments.join(' '));
  }

  hand.summaryTitle=(hand.heroPos?hand.heroPos:'Hand')+' — '+(boardStr('flop')||'—');
  return lines.join('\n');
}
async function copySummary(){try{await navigator.clipboard.writeText(buildSummaryText())}catch(e){}}

/* ---- Defaults persistence: save & apply next time ---- */
function updateDefaultsFromHand(h){
  if(!h) return;
  const seatMap = {};
  (h.players||[]).forEach(p=>{
    const nm = p.isHero ? (h.heroProfile || p.name) : p.name;
    seatMap[p.pos] = nm;
  });
  const def = {
    currency: h.currency,
    blinds: { sb: +h.blinds.sb, bb: +h.blinds.bb },
    playersN: clamp(+h.playersN,3,9),
    effective: { bb: +h.effective.bb, eur: +h.effective.eur },
    heroPos: h.heroPos,
    heroProfile: h.heroProfile || '',
    seatMap
  };
  localSave(DEFAULTS_KEY, def);
}

function saveHand(){
  const copy=JSON.parse(JSON.stringify(hand));
  copy.savedText=buildSummaryText();
  const idx=app.hands.findIndex(x=>x.id===copy.id);
  if(idx>=0){ app.hands[idx]=copy; } else { app.hands.push(copy); }
  localSave('hands',app.hands);

  // Save defaults so the next "Start a new hand" uses this setup
  updateDefaultsFromHand(copy);

  renderHandsList();
}

/* -------- Profiles plumbing (unchanged) -------- */
function addCategoryHome(){
  const name=$('#categoryNameHome').value.trim();
  if(!name) return;
  const cat={id:id(),name};
  app.profileCategories.push(cat);
  localSave('profileCategories',app.profileCategories);
  $('#categoryNameHome').value='';
  renderCategoriesHome();
}
function deleteCategory(catId){
  if(catId==='all') return;
  app.profiles.forEach(p=>{ if(p.categoryId===catId) p.categoryId='all'; });
  app.profileCategories = app.profileCategories.filter(c=>c.id!==catId);
  localSave('profiles',app.profiles);
  localSave('profileCategories',app.profileCategories);
  renderCategoriesHome();
}
function renderCategoriesHome(){
  const box=$('#categoriesListHome'); box.innerHTML='';
  const cats=[...app.profileCategories];
  cats.forEach(cat=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(cat.name)}</strong></div>
      <div class="row">
        <button class="btn ghost" data-open="${cat.id}">Open</button>
        ${cat.id!=='all'?`<button class="btn" data-del="${cat.id}" style="background:#ff6b6b">Delete</button>`:''}
      </div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open');
      const delId=e.target.getAttribute('data-del');
      if(openId){ openCategory(openId); }
      if(delId){ deleteCategory(delId); }
    });
    box.appendChild(it);
  });
}
function openCategory(catId){
  currentCatId = catId || 'all';
  renderProfilesInCategory();
  show('viewProfileCategory');
}
function renderProfilesInCategory(){
  const cat = app.profileCategories.find(c=>c.id===currentCatId) || {id:'all',name:'All'};
  $('#catTitle').textContent = `Category: ${cat.name}`;
  const box=$('#profilesListInCat'); box.innerHTML='';
  const list = app.profiles.filter(p=> (currentCatId==='all' ? true : p.categoryId===currentCatId));
  if(!list.length){ box.innerHTML='<div class="item">No profiles in this category.</div>'; return; }
  list.forEach(p=>{
    const it=document.createElement('div'); it.className='item';
    it.innerHTML=`<div><strong>${escape(p.name)}</strong><div class="meta">${cat.name}</div></div>
      <div class="row">
        <button class="btn ghost" data-open="${p.id}">Open</button>
        <button class="btn" data-del="${p.id}" style="background:#ff6b6b">Delete</button>
      </div>`;
    it.addEventListener('click',e=>{
      const openId=e.target.getAttribute('data-open');
      const delId=e.target.getAttribute('data-del');
      if(openId){ openProfile(openId); }
      if(delId){ deleteProfile(delId); }
    });
    box.appendChild(it);
  });
}
function addProfile(catId, inputSel, listSel){
  const input=$(inputSel);
  const name=input.value.trim();
  if(!name) return;
  app.profiles.push({id:id(),name,categoryId:catId||'all',notes:'',aliases:[]});
  localSave('profiles',app.profiles);
  input.value='';
  if(listSel==='#profilesListInCat') renderProfilesInCategory();
  renderProfiles();
  renderCategoriesHome();
}
function deleteProfile(pid){
  app.profiles = app.profiles.filter(p=>p.id!==pid);
  localSave('profiles',app.profiles);
  renderProfilesInCategory();
  renderProfiles();
}
function openProfile(pid){
  currentProfileId = pid;
  renderProfileDetail();
  show('viewProfileDetail');
}
function saveProfileDetail(){
  const p = app.profiles.find(x=>x.id===currentProfileId);
  if(!p) return;
  const newName = $('#profNameInput').value.trim() || p.name;
  if(newName !== p.name){
    if(!p.aliases.includes(p.name)) p.aliases.push(p.name);
    p.name = newName;
  }
  p.notes = $('#profNotes').value;
  localSave('profiles',app.profiles);
  renderProfilesInCategory();
  renderCategoriesHome();
}
function renderProfileDetail(){
  const p = app.profiles.find(x=>x.id===currentProfileId);
  if(!p){ $('#profTitle').textContent='Profile'; $('#profNameInput').value=''; $('#profNotes').value=''; $('#handsByProfile').innerHTML=''; return; }
  $('#profTitle').textContent = `Profile: ${p.name}`;
  $('#profNameInput').value = p.name;
  $('#profNotes').value = p.notes || '';

  const namesToMatch = new Set([p.name, ...(p.aliases||[])].filter(Boolean));
  const hands = app.hands.filter(h=>{
    if(namesToMatch.has(h.heroProfile)) return true;
    if(Array.isArray(h.players) && h.players.some(pl=> namesToMatch.has(pl.name))) return true;
    return false;
  });
  const box=$('#handsByProfile'); box.innerHTML='';
  if(!hands.length){ box.innerHTML='<div class="item">No hands for this player yet.</div>'; }
  else{
    hands.slice().reverse().forEach(h=>{
      const it=document.createElement('div'); it.className='item';
      it.innerHTML=`<div><strong>${escape(h.summaryTitle||'Hand')}</strong><div class="meta">${escape(h.created||'')}</div></div>
                    <div class="row"><button class="btn ghost" data-open="${h.id}">Open</button></div>`;
      it.addEventListener('click',e=>{
        const openId=e.target.getAttribute('data-open');
        if(openId){ openSavedHand(openId); }
      });
      box.appendChild(it);
    });
  }
}
function renderProfiles(){
  const box=$('#profilesList'); if(!box)return;
  box.innerHTML='';
  if(!app.profiles.length){box.innerHTML='<div class="item">No profiles yet.</div>';return}
  app.profiles.forEach(p=>{
    const cat = app.profileCategories.find(c=>c.id===p.categoryId)?.name || 'All';
    const it=document.createElement('div');it.className='item';
    it.innerHTML=`<div><strong>${escape(p.name)}</strong><div class="meta">${escape(cat)}</div></div>
                  <div class="row">
                    <button class="btn ghost" data-open="${p.id}">Open</button>
                    <button class="btn" data-del="${p.id}" style="background:#ff6b6b">Delete</button>
                  </div>`;
    it.addEventListener('click',e=>{
      const del=e.target.getAttribute('data-del');
      const open=e.target.getAttribute('data-open');
      if(del){app.profiles=app.profiles.filter(x=>x.id!==del);localSave('profiles',app.profiles);renderProfiles();renderCategoriesHome()}
      if(open){ openProfile(open); }
    });
    box.appendChild(it)
  })
}

/* ---- utilities ---- */
function escape(s){return (s||'').replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;"," >":"&gt;","\"":"&quot;","'":"&#039;"}[m]) || m)}
function safeFmtCurrency(v){ if(v==null || isNaN(v)) return ''; return String((Math.round(v*100)/100).toFixed(2)).replace(/\.00$/,''); }
function trimZeros(x){ const s = (Math.round(x*100)/100).toFixed(2); return s.replace(/\.00$/,'').replace(/(\.\d)0$/,'$1'); }

/* ---- kick it off ---- */
</script>
</body>
</html>
